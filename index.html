<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%22256%22 height=%22256%22 viewBox=%220 0 100 100%22><rect width=%22100%22 height=%22100%22 rx=%2220%22 fill=%22%23000000%22></rect><path d=%22M9.46 72.40L9.46 27.60L20.08 27.60Q25.52 27.60 28.02 30.13Q30.51 32.66 30.51 37.90L30.51 37.90L30.51 39.70Q30.51 43.15 29.39 45.33Q28.27 47.50 25.97 48.46L25.97 48.46L25.97 48.59Q31.22 50.38 31.22 57.94L31.22 57.94L31.22 61.78Q31.22 66.96 28.50 69.68Q25.78 72.40 20.53 72.40L20.53 72.40L9.46 72.40ZM16.50 45.84L19.25 45.84Q21.36 45.84 22.42 44.75Q23.47 43.66 23.47 41.10L23.47 41.10L23.47 38.61Q23.47 36.18 22.61 35.09Q21.74 34.00 19.89 34.00L19.89 34.00L16.50 34.00L16.50 45.84ZM16.50 66L20.53 66Q22.38 66 23.28 65.01Q24.18 64.02 24.18 61.58L24.18 61.58L24.18 57.68Q24.18 54.61 23.12 53.42Q22.06 52.24 19.63 52.24L19.63 52.24L16.50 52.24L16.50 66ZM33.90 72.40L33.90 66.13L46.96 34.00L34.54 34.00L34.54 27.60L54.51 27.60L54.51 33.87L41.46 66L54.51 66L54.51 72.40L33.90 72.40ZM61.36 72.40L56.82 27.60L63.60 27.60L66.74 62.03L66.86 62.03L70.19 27.60L77.87 27.60L81.20 62.03L81.33 62.03L84.46 27.60L90.54 27.60L86 72.40L77.23 72.40L74.03 42.19L73.90 42.19L70.70 72.40L61.36 72.40Z%22 fill=%22%23fff%22></path></svg>">
  <title>Web BZW</title>
  <style>@import url("https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600&display=swap");*{color:var(--text-color);box-sizing:border-box;-webkit-tap-highlight-color:transparent;}:root{font-size:18px;--shadow-color:rgba(0, 0, 0, .05);--shadow-height:.2rem;--shadow-spread:.5rem;--scrollbar-size:.5rem;--border-radius:.25rem;/* color theme */--background-color:#17171C;--border-color:#27272F;--text-color:#FFF;--text-light-color:#BBB;--selection-color:rgba(255, 255, 255, .2);--highlight-default:#E9E9E9;--highlight-comment:#888;--highlight-number:#F93;--highlight-symbol:#3AF;--highlight-headers:#F55;--highlight-keyword:#A8F;--highlight-flag:#AC8;}:root[data-theme=high-contrast]{--background-color:#000;--border-color:#777;--text-light-color:#FFF;--selection-color:rgba(255, 255, 255, .3);--highlight-default:#FFF;--highlight-comment:#CCC;}:root[data-theme=one-dark-pro]{--background-color:#282C34;--border-color:#454C5A;--highlight-default:#ABB2Bf;--highlight-comment:#5C6370;--highlight-number:#D19A66;--highlight-symbol:#61AEEE;--highlight-headers:#E06C75;--highlight-keyword:#C678DD;--highlight-flag:#98C379;}:root[data-theme=one-half-light]{--background-color:#FFF;--border-color:#EEE;--text-color:#000;--text-light-color:#444;--selection-color:rgba(0, 0, 0, .2);--highlight-default:#383A42;--highlight-comment:#A0A1A7;--highlight-number:#C18401;--highlight-symbol:#0184BC;--highlight-headers:#E45649;--highlight-keyword:#A626A4;--highlight-flag:#50A14F;}:root[data-theme=palenight]{--background-color:#292D3E;--border-color:#424864;--selection-color:#7580B850;--highlight-default:#BFC7D5;--highlight-comment:#697098;--highlight-number:#F78C6C;--highlight-symbol:#82AAFF;--highlight-headers:#FFCB6B;--highlight-keyword:#C792EA;--highlight-flag:#C3E88D;}:root[data-theme=one-monokai]{--background-color:#282C34;--border-color:#454C5A;--highlight-default:#F8FAFD;--highlight-comment:#676F7D;--highlight-number:#C678DD;--highlight-symbol:#56B6C2;--highlight-headers:#E06C75;--highlight-keyword:#98C379;--highlight-flag:#E5C07B;}body{height:100vh;margin:0;background-color:var(--background-color);font-family:Montserrat, sans-serif;display:flex;flex-direction:column;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}h1{margin:0;line-height:1em;}input[type=file]{display:none;}input[type=checkbox]{cursor:pointer;}header{padding:0 1rem;background-color:var(--border-color);display:flex;flex-direction:row;box-shadow:0 var(--shadow-height) var(--shadow-spread) var(--shadow-color);z-index:9;}header > span{margin-right:1rem;font-weight:600;display:flex;align-items:center;}nav{display:flex;}nav input[type=checkbox]{margin-right:.5rem;}nav a{text-decoration:none;flex:1;}nav > div{font-size:.9rem;user-select:none;}nav > div:hover, nav .menu > span:hover{background-color:var(--selection-color);}nav > .parent > span{padding:.2rem .75rem;display:block;}nav .parent{position:relative;}nav .parent:hover > .menu{display:flex;}nav .menu{width:15rem;padding:.5rem 0;background-color:var(--background-color);position:absolute;display:none;flex-direction:column;border:1px solid var(--border-color);box-shadow:0 var(--shadow-height) var(--shadow-spread) var(--shadow-color);cursor:default;z-index:9;}nav .menu.submenu{margin-top:-1px;margin-left:-2px;top:-.5rem;left:15rem;}nav > .menu:not(.submenu){border-top:none;}nav .menu > span{padding:.3rem 1rem;font-size:.85rem;display:flex;align-items:center;cursor:pointer;}nav .shortcut{padding-left:1rem;font-size:.8em;font-family:"Source Code Pro", monospace;text-align:right;flex:1;opacity:.75;}footer{padding:.25rem .5rem;background-color:var(--border-color);font-size:.7rem;display:flex;box-shadow:0 calc(var(--shadow-height) * -1) var(--shadow-spread) var(--shadow-color);z-index:1;}footer > span:not(:last-child){margin-right:1rem;}main{flex:1;display:flex;overflow:auto;}main > *:not(.resizer):not(.line-numbers){flex:1;}pre{margin:0;}select{padding:.2rem;background-color:var(--background-color);font-family:Montserrat, sans-serif;font-size:.8rem;font-weight:500;border:none;border-radius:var(--border-radius);outline:none;cursor:pointer;}textarea{padding-right:2rem;background:none;color:transparent;caret-color:var(--highlight-default);resize:none;border:none;border-radius:0;outline:none;white-space:pre;z-index:1;}textarea::selection{background-color:var(--selection-color);}textarea::-webkit-scrollbar, .tree > .objects::-webkit-scrollbar{width:var(--scrollbar-size);height:var(--scrollbar-size);border-left:1px solid var(--border-color);}textarea::-webkit-scrollbar-thumb, .tree > .objects::-webkit-scrollbar-thumb{background:var(--border-color);border-radius:var(--scrollbar-size);}textarea::-webkit-scrollbar-thumb:hover, .tree > .objects::-webkit-scrollbar-thumb:hover{background:var(--text-color);}textarea.show{color:var(--highlight-default);}.btn{padding:.2rem .5rem;background:none;font-size:.8rem;font-family:"Source Code Pro", monospace;border:1px solid var(--border-color);border-radius:var(--border-radius);outline:none;cursor:pointer;}.btn:hover{background-color:var(--border-color);}.beta{margin-left:.5rem;padding:.1rem .5rem;background-color:#F005;font-size:.8rem;font-weight:500;border:1px solid #F00;border-radius:1rem;}.tree > *, .line-numbers, .editor > *{padding:.2rem .5rem;font-size:.8rem;font-family:"Source Code Pro", monospace;line-height:1em;}.tree{display:flex;flex-direction:column;border-right:1px solid var(--border-color);}.tree > .objects{display:flex;flex-direction:column;flex:1;overflow:auto;user-select:none;}.tree > .objects > div{padding:.1rem;color:var(--text-light-color);cursor:pointer;}.tree > .objects > div.selected, .tree > .objects > div:hover{color:var(--text-color);}.tree > .properties{display:none; /* flex */flex-direction:column;border-top:1px solid var(--border-color);}.tree > .properties > div{display:flex;flex-direction:row;align-items:center;}.tree > .properties > div:not(:last-child){margin-bottom:.5rem;}.tree > .properties > div > *:not(input[type=checkbox]){flex:1;}.tree > .properties > div > *:not(:last-child){margin-right:.2rem;}.tree > .properties input{padding:.2rem .5rem;background:none;font-family:"Source Code Pro", monospace;font-size:.8rem;border:1px solid var(--border-color);border-radius:var(--border-radius);outline:none;}.tree > .properties input:not([type=checkbox]){width:100%;}.line-numbers{margin:0;color:#888;text-align:right;display:flex;flex-direction:column;border-right:1px solid var(--border-color);overflow:hidden;user-select:none;}.editor{display:flex;position:relative;border-right:1px solid var(--border-color);}.editor > *{flex:1;overflow:auto;}.resizer{--width:.5rem;width:var(--width);margin-left:calc(var(--width) * -.3);margin-right:calc(var(--width) * -.7);cursor:ew-resize;z-index:2;}.highlight{position:absolute;top:0;bottom:0;left:0;right:0;pointer-events:none;overflow:hidden;}/* make empty lines take up vertical space */.highlight > div:empty::after{content:".";visibility:hidden;}.highlight div{color:var(--highlight-default);}.highlight .comment{color:var(--highlight-comment);}.highlight .number{color:var(--highlight-number);}.highlight .symbol{color:var(--highlight-symbol);}.highlight .header{color:var(--highlight-headers);}.highlight .keyword{color:var(--highlight-keyword);}.highlight .flag{color:var(--highlight-flag);}@media only screen and (max-width:768px){main{flex-direction:column;}.line-numbers{display:none}}</style>
</head>
<body>
  <header>
    <span>Web BZW <span class="beta">Beta</span></span>
    <nav>
      <div class="parent">
        <span>File</span>
        <div class="menu">
          <span onclick="bzwFile.click()">
            Open
            <span class="shortcut">Ctrl+O</span>
          </span>
          <span onclick="saveMap()">
            Save
            <span class="shortcut">Ctrl+S</span>
          </span>
        </div>
      </div>
      <div class="parent">
        <span>Edit</span>
        <div class="menu">
          <span onclick="toggleComment()">
            Toggle Commnt
            <span class="shortcut">Ctrl+/</span>
          </span>
        </div>
      </div>
      <div class="parent">
        <span>View</span>
        <div class="menu">
          <span onclick="settings.autoRotate.click()">
            <input type="checkbox" id="auto-rotate" onclick="event.stopPropagation()">
            Auto Rotate
          </span>
          <span onclick="settings.showAxis.click()">
            <input type="checkbox" id="show-axis" onclick="event.stopPropagation()">
            Show Axis
          </span>
          <span onclick="settings.syntaxHighlighting.click()">
            <input type="checkbox" id="syntax-highlighting" onclick="event.stopPropagation()">
            Syntax Highlighting
          </span>
          <span class="parent">
            Color Theme
            <span class="shortcut">&gt;</span>
            <div class="menu submenu" onclick="setColorTheme(event)">
              <span>Default</span>
              <span>High Contrast</span>
              <span>One Dark Pro</span>
              <span>One Half Light</span>
              <span>Palenight</span>
              <span>One Monokai</span>
            </div>
          </span>
        </div>
      </div>
      <div class="parent">
        <span>Help</span>
        <div class="menu">
          <span><a href="https://github.com/BZFlagCommunity/webbzw/issues/new?labels=bug" target="_blank" rel="noopener noreferrer">Report a Bug</a></span>
          <span><a href="https://github.com/BZFlagCommunity/webbzw/releases/v0.3.0" target="_blank" rel="noopener noreferrer">v0.3.0</a></span>
        </div>
      </div>
    </nav>
    <input type="file" id="bzw-file" accept=".bzw">
  </header>
  <main>
    <div class="tree">
      <div class="objects"></div>
      <div class="properties"></div>
    </div>
    <pre class="line-numbers"></pre>
    <div class="editor">
      <textarea spellcheck="false"></textarea>
      <pre class="highlight">
        <span class="comment"># loading...</span>
      </pre>
    </div>
    <div class="resizer"></div>
    <canvas></canvas>
  </main>
  <footer>
    <span id="objects"></span>
    <span id="vertices"></span>
    <span style="flex:1"></span>
    <span><a href="https://github.com/BZFlagCommunity/webbzw" target="_blank" rel="noopener noreferrer">GitHub</a></span>
    <span>Copyright &copy; 2021 <a href="https://thenoah.dev" target="_blank" rel="noopener noreferrer">The Noah</a></span>
  </footer>
  <script>function getProjection(angle, aspectRatio, zMin, zMax) {const ang = Math.tan(angle * 0.5 * Math.PI / 180);return [0.5 / ang,0,0,0,0,0.5 * aspectRatio / ang,0,0,0,0,-(zMax + zMin) / (zMax - zMin),-1,0,0,-2 * zMax * zMin / (zMax - zMin),0];}function multiplyMatrices(a, b) {const result = [];const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];result[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;result[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;result[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;result[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;b0 = b[4];b1 = b[5];b2 = b[6];b3 = b[7];result[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;result[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;result[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;result[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;b0 = b[8];b1 = b[9];b2 = b[10];b3 = b[11];result[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;result[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;result[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;result[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;b0 = b[12];b1 = b[13];b2 = b[14];b3 = b[15];result[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;result[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;result[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;result[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;return result;}function multiplyArrayOfMatrices(matrices) {let inputMatrix = matrices[0];for(let i = 1; i < matrices.length; i++){inputMatrix = multiplyMatrices(inputMatrix, matrices[i]);}return inputMatrix;}function rotateXMatrix(angle) {angle *= Math.PI / 180;return [1,0,0,0,0,Math.cos(angle),-Math.sin(angle),0,0,Math.sin(angle),Math.cos(angle),0,0,0,0,1];}function rotateYMatrix(angle) {angle *= Math.PI / 180;return [Math.cos(angle),0,Math.sin(angle),0,0,1,0,0,-Math.sin(angle),0,Math.cos(angle),0,0,0,0,1];}function rotY(position, angle) {const s = Math.sin(angle);const c = Math.cos(angle);let x = 0, z = 0;z = position[2] * c - position[0] * s;x = position[2] * s + position[0] * c;return [x,position[1],z];}const textarea = document.querySelector(".editor textarea");const editor = document.querySelector(".editor");const canvas = document.querySelector("canvas");const lineNumbersElement = document.querySelector(".line-numbers");const bzwFile = document.querySelector("#bzw-file");const tree = {root: document.querySelector(".tree"),objects: document.querySelector(".tree > .objects"),properties: document.querySelector(".tree > .properties")};const statusBar = {objects: document.querySelector("#objects"),vertices: document.querySelector("#vertices")};const settings = {autoRotate: document.querySelector("#auto-rotate"),showAxis: document.querySelector("#show-axis"),syntaxHighlighting: document.querySelector("#syntax-highlighting")};function removeAllChildren(target) {while(target.lastChild){target.lastChild.remove();}}function updateLineNumbers() {lineNumbersElement.innerHTML = [...Array(textarea.value.split("\n").length).keys()].map((i)=>i + 1).join("\n");lineNumbersElement.scrollTop = textarea.scrollTop;}for (const resizer of document.querySelectorAll(".resizer")){const parent = resizer.parentElement;const leftSide = resizer.previousElementSibling;const rightSide = resizer.nextElementSibling;let x = 0;let rightWidth = 0;const mouseDownHandler = (e)=>{x = e.clientX;rightWidth = rightSide.width;resizer.style.cursor = "col-resize";document.body.style.cursor = "col-resize";leftSide.style.userSelect = "none";leftSide.style.pointerEvents = "none";rightSide.style.userSelect = "none";rightSide.style.pointerEvents = "none";document.addEventListener("mousemove", mouseMoveHandler);document.addEventListener("mouseup", mouseUpHandler);};const mouseMoveHandler = (e)=>{if (!parent) {return;}const dx = e.clientX - x;const parentWidth = parent.getBoundingClientRect().width;const minWidth = parentWidth / 2;const maxWidth = parentWidth - parentWidth / 4;let newRightWidth = rightWidth - dx;if (newRightWidth < minWidth) {newRightWidth = minWidth;} else if (newRightWidth > maxWidth) {newRightWidth = maxWidth;}rightSide.width = newRightWidth;};const mouseUpHandler = function() {resizer.style.removeProperty("cursor");document.body.style.removeProperty("cursor");leftSide.style.removeProperty("user-select");leftSide.style.removeProperty("pointer-events");rightSide.style.removeProperty("user-select");rightSide.style.removeProperty("pointer-events");document.removeEventListener("mousemove", mouseMoveHandler);document.removeEventListener("mouseup", mouseUpHandler);};resizer.addEventListener("mousedown", mouseDownHandler);}function getCoord(e, coord) {return e.touches ? e.touches[0][`page${coord}`] : e[`page${coord}`];}function saveFile(fileName, text) {const blob = new Blob([text], {type: "text/plain"});const link = document.createElement("a");link.download = fileName;link.href = window.URL.createObjectURL(blob);link.style.display = "none";document.body.appendChild(link);link.click();link.remove();}function colorThemeChanged() {document.documentElement.setAttribute("data-theme", localStorage.getItem("colorTheme") ?? "default");}function trimText(text) {return text.split("\n").map((line)=>line.replace(/\s+$/g, "")).join("\n");}colorThemeChanged();const VERTEX_SHADER = `#version 300 es\nlayout(location = 0) in vec3 position;\nlayout(location = 1) in vec4 color;\n\nout vec4 vColor;\n\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\n\nvoid main(void){\n  vColor = color;\n\n  gl_Position = proj * view * model * vec4(position, 1.0);\n}`;const FRAGMENT_SHADER = `#version 300 es\nprecision highp float;\n\nin vec4 vColor;\n\nout vec4 finalColor;\n\nvoid main(void){\n  if(vColor.a < .05){\n    discard;\n  }\n\n  finalColor = vColor;\n}`;function createShader(gl, vertCode, fragCode) {const vertShader = gl.createShader(gl.VERTEX_SHADER);if (!vertShader) {return null;}gl.shaderSource(vertShader, vertCode);gl.compileShader(vertShader);if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {console.error("Error compiling vertex shader: ", gl.getShaderInfoLog(vertShader));gl.deleteShader(vertShader);return null;}const fragShader = gl.createShader(gl.FRAGMENT_SHADER);if (!fragShader) {return null;}gl.shaderSource(fragShader, fragCode);gl.compileShader(fragShader);if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {console.error("Error compiling fragment shader: ", gl.getShaderInfoLog(fragShader));gl.deleteShader(fragShader);return null;}const shader = gl.createProgram();if (!shader) {return null;}gl.attachShader(shader, vertShader);gl.attachShader(shader, fragShader);gl.linkProgram(shader);return shader;}const MAX_ZOOM = -5;class Renderer {worldSize = 400;vbo = null;cbo = null;ebo = null;elementCount = 0;constructor(canvas1){if (!canvas1) {return;}this.gl = canvas1.getContext("webgl2");if (!this.gl) {alert("WebGL 2.0 not available");return;}const viewMatrix = [1,0,0,0,0,1,0,0,0,0,1,0,0,0,-this.worldSize,1];const modelMatrix = [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];let drag = false;let oldX = 0, oldY = 0;let dX = 0, dY = 0;let THETA = 0, PHI = 40, oldTime = 0;canvas1.width = canvas1.offsetWidth;canvas1.height = canvas1.offsetHeight;const mouseDown = (e)=>{e.preventDefault();drag = true;oldX = getCoord(e, "X");oldY = getCoord(e, "Y");};const mouseUp = ()=>{drag = false;};const mouseMove = (e)=>{e.preventDefault();if (!drag) {return;}const x = getCoord(e, "X");const y = getCoord(e, "Y");dX = (x - oldX) * 75 * Math.PI / canvas1.width;dY = (y - oldY) * 75 * Math.PI / canvas1.height;THETA += dX;PHI += dY;oldX = x;oldY = y;};canvas1.addEventListener("mousedown", mouseDown, false);canvas1.addEventListener("mouseup", mouseUp, false);canvas1.addEventListener("mouseout", mouseUp, false);canvas1.addEventListener("mousemove", mouseMove, false);canvas1.addEventListener("touchstart", mouseDown, false);canvas1.addEventListener("touchend", mouseUp, false);canvas1.addEventListener("touchmove", mouseMove, false);canvas1.addEventListener("wheel", (e)=>{const delta = e.deltaY;viewMatrix[14] += delta / Math.abs(delta) * (viewMatrix[14] / 10);viewMatrix[14] = viewMatrix[14] > MAX_ZOOM ? MAX_ZOOM : viewMatrix[14] < -this.worldSize * 3 ? -this.worldSize * 3 : viewMatrix[14];});const shader = createShader(this.gl, VERTEX_SHADER, FRAGMENT_SHADER);if (!shader) {alert("Error creating shader");return;}this.gl.useProgram(shader);const vMatrix = this.gl.getUniformLocation(shader, "view");const mMatrix = this.gl.getUniformLocation(shader, "model");const axisVertices = [0,0,0,150,0,0,0,0,0,0,150,0,0,0,0,0,0,-150,];const axisColors = [1,0,0,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,0,0,1,1];const axisVao = this.gl.createVertexArray();this.gl.bindVertexArray(axisVao);const axisVbo = this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER, axisVbo);this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(axisVertices), this.gl.STATIC_DRAW);const axisCbo = this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER, axisCbo);this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(axisColors), this.gl.STATIC_DRAW);this.gl.bindBuffer(this.gl.ARRAY_BUFFER, axisVbo);this.gl.enableVertexAttribArray(0);this.gl.vertexAttribPointer(0, 3, this.gl.FLOAT, false, 0, 0);this.gl.bindBuffer(this.gl.ARRAY_BUFFER, axisCbo);this.gl.enableVertexAttribArray(1);this.gl.vertexAttribPointer(1, 4, this.gl.FLOAT, false, 0, 0);this.gl.bindVertexArray(null);this.gl.deleteBuffer(axisVbo);this.gl.deleteBuffer(axisCbo);this.gl.enable(this.gl.DEPTH_TEST);this.gl.enable(this.gl.BLEND);this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);this.gl.enable(this.gl.CULL_FACE);this.gl.clearColor(0, 0, 0, 0);const render = (time)=>{if (!this.gl) {return;}if (oldTime === 0) {oldTime = time;}const dt = time - oldTime;oldTime = time;if (!drag && settings.autoRotate.checked) {THETA += 0.015 * dt;}if (PHI > 90) {PHI = 90;} else if (PHI < -90) {PHI = -90;}const finalModelMatrix = multiplyArrayOfMatrices([rotateXMatrix(-PHI),rotateYMatrix(-THETA),modelMatrix,]);this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);this.gl.viewport(0, 0, canvas1.width, canvas1.height);this.gl.uniformMatrix4fv(this.gl.getUniformLocation(shader, "proj"), false, getProjection(60, canvas1.width / canvas1.height, 1, this.worldSize * 5));this.gl.uniformMatrix4fv(vMatrix, false, viewMatrix);this.gl.uniformMatrix4fv(mMatrix, false, finalModelMatrix);this.gl.drawElements(this.gl.TRIANGLES, this.elementCount, this.gl.UNSIGNED_SHORT, 0);if (settings.showAxis.checked) {this.gl.disable(this.gl.DEPTH_TEST);this.gl.bindVertexArray(axisVao);this.gl.drawArrays(this.gl.LINES, 0, 6);this.gl.bindVertexArray(null);this.gl.enable(this.gl.DEPTH_TEST);}requestAnimationFrame(render);};requestAnimationFrame(render);}updateMesh(mesh) {if (!this.gl) {return;}this.elementCount = mesh.indices.length;this.gl.deleteBuffer(this.vbo);this.gl.deleteBuffer(this.cbo);this.gl.deleteBuffer(this.ebo);this.vbo = this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbo);this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(mesh.vertices), this.gl.STATIC_DRAW);this.cbo = this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.cbo);this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(mesh.colors), this.gl.STATIC_DRAW);this.ebo = this.gl.createBuffer();this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.ebo);this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(mesh.indices), this.gl.STATIC_DRAW);this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbo);this.gl.enableVertexAttribArray(0);this.gl.vertexAttribPointer(0, 3, this.gl.FLOAT, false, 12, 0);this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.cbo);this.gl.enableVertexAttribArray(1);this.gl.vertexAttribPointer(1, 4, this.gl.FLOAT, false, 16, 0);this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);}}const renderer = new Renderer(canvas);let source = localStorage.getItem("bzw") || `# sample world\n\nworld\n  size 200\nend\n\nbox\n  position 0 0 0\n  size 30 30 15\n  rotation 45\nend\n\npyramid\n  position 50 50 0\n  size 5 5 50\nend\n\npyramid\n  position -50 50 0\n  size 5 5 50\nend\n\npyramid\n  position 50 -50 0\n  size 5 5 50\nend\n\npyramid\n  position -50 -50 0\n  size 5 5 50\nend\n\nbase\n  position -170 0 0\n  size 30 30 .5\n  color 1\nend\n\nbase\n  position 170 0 0\n  size 30 30 .5\n  color 2\nend\n`;textarea.value = source;let map = {worldSize: 400,objects: []};function handleFile(files) {const file = files ? files[0] : undefined;if (!file) {alert("No file selected!");return;}const reader = new FileReader();reader.addEventListener("load", ()=>{const text = reader.result;textarea.value = text;textareaChanged();});reader.addEventListener("error", ()=>{alert("Error: failed to read file");});reader.readAsText(file);}const INDENT = "  ";function parseNum(str, fallback = 0) {const value = parseFloat(str);if (isNaN(value)) {return fallback;}return value;}class MapObject {name = "";vertexCount = 0;constructor(line1){}toString() {let ret = `${this.HEADER}\n`;const properties = Object.keys(this);const values = Object.values(this);for(const i in properties){const property = properties[i];let value = values[i];if (["vertexCount","HEADER"].includes(property)) {continue;}if (!value || Array.isArray(value) && value.filter((val)=>val).length === 0) {continue;}if (this.HEADER === "zone" && property === "color" || this.HEADER === "group" && property === "position") {continue;}ret += `${INDENT}${property}`;if (typeof value === "number" || typeof value === "string") {ret += ` ${value}`;} else if (typeof value === "object" && Array.isArray(value) && typeof value[0] !== "object") {ret += ` ${value.join(" ")}`;} else if (typeof value === "object" && Array.isArray(value) && typeof value[0] === "object") {value = value.map((val)=>val.toString().split("\n").map((line1)=>`${INDENT}${line1}`).join("\n"));ret += `\n${value.join("\n\n")}`;}ret += "\n";}ret += "end";return ret;}parseLine(line) {const parts = line.split(" ");if (parts[0] === "name") {this.name = parts.slice(1).join(" ");}}pushIndices(mesh) {mesh.indices.push(mesh.indicesCount);mesh.indices.push(mesh.indicesCount + 1);mesh.indices.push(mesh.indicesCount + 2);mesh.indices.push(mesh.indicesCount + 2);mesh.indices.push(mesh.indicesCount + 3);mesh.indices.push(mesh.indicesCount);mesh.indicesCount += 4;}pushColors(mesh, count = 1, r = 0, g = 0, b = 0, a = 1) {for(let i = 0; i < count; i++){mesh.colors.push(r, g, b, a);}}}class VeryBasicMapObject extends MapObject {position = [0,0,0];rotation = 0;shift = [0,0,0];parseLine(line) {super.parseLine(line);const parts = line.split(" ");if (parts[0] === "position") {this.position = [parseNum(parts[1]),parseNum(parts[2]),parseNum(parts[3])];} else if (parts[0] === "shift") {this.shift = [parseNum(parts[1]),parseNum(parts[2]),parseNum(parts[3])];} else if (parts[0] === "rotation") {this.rotation = parseNum(parts[1]);}}applyRotPosShift(mesh) {if (this.vertexCount === 0) {console.error("this should not happen");return;}this.applyRotation(mesh);for(let i = mesh.vertices.length - this.vertexCount; i < mesh.vertices.length; i += 3){mesh.vertices[i] += this.position[0] + this.shift[0];}for(let i1 = mesh.vertices.length - (this.vertexCount - 1); i1 < mesh.vertices.length; i1 += 3){mesh.vertices[i1] += this.position[2] + this.shift[2];}for(let i2 = mesh.vertices.length - (this.vertexCount - 2); i2 < mesh.vertices.length; i2 += 3){mesh.vertices[i2] -= this.position[1] + this.shift[1];}}applyRotation(mesh) {if (this.vertexCount === 0) {console.error("this should not happen");return;}const _rotation = this.rotation * Math.PI / 180;for(let i = mesh.vertices.length - this.vertexCount; i < mesh.vertices.length; i += 3){const rot = rotY([mesh.vertices[i],mesh.vertices[i + 1],mesh.vertices[i + 2]], _rotation);mesh.vertices[i] = rot[0];mesh.vertices[i + 1] = rot[1];mesh.vertices[i + 2] = rot[2];}}}class BasicMapObject extends VeryBasicMapObject {size = [0,0,0];color = undefined;parseLine(line) {super.parseLine(line);const parts = line.split(" ");if (parts[0] === "size") {this.size = [parseNum(parts[1], 0.5),parseNum(parts[2], 0.5),parseNum(parts[3], 1)];if (parseFloat(parts[3]) === 0) {this.size[2] = 0.01;}} else if (parts[0] === "color") {this.color = [parseNum(parts[1], 1),parseNum(parts[2], 1),parseNum(parts[3], 1),parseNum(parts[4], 1)];}}}const DEFAULT_COLOR = [0.61,0.26,0.12,1];class Box extends BasicMapObject {HEADER = "box";vertexCount = 72;buildMesh(mesh) {let { size , color  } = this;let defaultColor = false;if (!color) {defaultColor = true;color = DEFAULT_COLOR;}mesh.vertices.push(-size[0], size[2], -size[1]);mesh.vertices.push(-size[0], size[2], size[1]);mesh.vertices.push(size[0], size[2], size[1]);mesh.vertices.push(size[0], size[2], -size[1]);this.pushIndices(mesh);mesh.vertices.push(size[0], 0, -size[1]);mesh.vertices.push(size[0], 0, size[1]);mesh.vertices.push(-size[0], 0, size[1]);mesh.vertices.push(-size[0], 0, -size[1]);this.pushIndices(mesh);mesh.vertices.push(size[0], 0, -size[1]);mesh.vertices.push(-size[0], 0, -size[1]);mesh.vertices.push(-size[0], size[2], -size[1]);mesh.vertices.push(size[0], size[2], -size[1]);this.pushIndices(mesh);mesh.vertices.push(size[0], size[2], size[1]);mesh.vertices.push(-size[0], size[2], size[1]);mesh.vertices.push(-size[0], 0, size[1]);mesh.vertices.push(size[0], 0, size[1]);this.pushIndices(mesh);mesh.vertices.push(-size[0], 0, -size[1]);mesh.vertices.push(-size[0], 0, size[1]);mesh.vertices.push(-size[0], size[2], size[1]);mesh.vertices.push(-size[0], size[2], -size[1]);this.pushIndices(mesh);mesh.vertices.push(size[0], size[2], -size[1]);mesh.vertices.push(size[0], size[2], size[1]);mesh.vertices.push(size[0], 0, size[1]);mesh.vertices.push(size[0], 0, -size[1]);this.pushIndices(mesh);this.applyRotPosShift(mesh);if (!defaultColor) {this.pushColors(mesh, 4, color[0], color[1], color[2], color[3]);this.pushColors(mesh, 4, color[0] * 0.7, color[1] * 0.7, color[2] * 0.7, color[3]);} else {this.pushColors(mesh, 8, 0.75, 0.75, 0.75, color[3]);}this.pushColors(mesh, 8, color[0] * 0.9, color[1] * 0.9, color[2] * 0.9, color[3]);this.pushColors(mesh, 8, color[0] * 0.8, color[1] * 0.8, color[2] * 0.8, color[3]);}}const parseNum1 = parseNum;const VeryBasicMapObject1 = VeryBasicMapObject;class Group extends VeryBasicMapObject {HEADER = "group";id = "";scale = [1,1,1];constructor(line2){super(line2);if (!line2) {return;}this.id = line2.split(" ")[1];}buildMesh(mesh) {if (!this.define || this.define.id !== this.id) {return;}for (const originalChild of this.define.children.slice()){const child = Object.create(originalChild);child.position = [child.position[0] * this.scale[0],child.position[1] * this.scale[1],child.position[2] * this.scale[2]];child.size = [child.size[0] * this.scale[0],child.size[1] * this.scale[1],child.size[2] * this.scale[2]];child.buildMesh(mesh);this.vertexCount += child.vertexCount;}super.applyRotPosShift(mesh);}toString() {let ret = super.toString().split("\n");ret[0] += ` ${this.id}`;ret = ret.filter((line3)=>!line3.endsWith(`id ${this.id}`) && !line3.endsWith("define"));return ret.join("\n");}parseLine(line) {super.parseLine(line);const parts = line.split(" ");if (parts[0] === "scale") {this.scale = [parseNum(parts[1], 1),parseNum(parts[2], 1),parseNum(parts[3], 1)];}}}const Box2 = Box;class MeshBox extends Box {HEADER = "meshbox";}const MeshBox2 = MeshBox;const BasicMapObject1 = BasicMapObject;const DEFAULT_COLOR1 = [0.1,0.3,1,1];class Pyramid extends BasicMapObject {HEADER = "pyramid";vertexCount = 48;buildMesh(mesh) {let { size , color  } = this;if (!color) {color = DEFAULT_COLOR1;}mesh.vertices.push(size[0], 0, -size[1]);mesh.vertices.push(size[0], 0, size[1]);mesh.vertices.push(-size[0], 0, size[1]);mesh.vertices.push(-size[0], 0, -size[1]);this.pushIndices(mesh);mesh.vertices.push(size[0], 0, size[1]);mesh.vertices.push(0, size[2], 0);mesh.vertices.push(-size[0], 0, size[1]);this.pushIndices2(mesh);mesh.vertices.push(-size[0], 0, -size[1]);mesh.vertices.push(0, size[2], 0);mesh.vertices.push(size[0], 0, -size[1]);this.pushIndices2(mesh);mesh.vertices.push(-size[0], 0, size[1]);mesh.vertices.push(0, size[2], 0);mesh.vertices.push(-size[0], 0, -size[1]);this.pushIndices2(mesh);mesh.vertices.push(size[0], 0, -size[1]);mesh.vertices.push(0, size[2], 0);mesh.vertices.push(size[0], 0, size[1]);this.pushIndices2(mesh);this.applyRotPosShift(mesh);this.pushColors(mesh, 4, color[0] * 0.8, color[1] * 0.8, color[2] * 0.8, color[3]);this.pushColors(mesh, 6, color[0] * 0.9, color[1] * 0.9, color[2] * 0.9, color[3]);this.pushColors(mesh, 6, color[0], color[1], color[2], color[3]);}pushIndices2(mesh) {mesh.indices.push(mesh.indicesCount);mesh.indices.push(mesh.indicesCount + 1);mesh.indices.push(mesh.indicesCount + 2);mesh.indicesCount += 3;}}const Pyramid1 = Pyramid;const Pyramid2 = Pyramid;const Pyramid3 = Pyramid;class MeshPyramid extends Pyramid {HEADER = "meshpyr";}const MeshPyramid1 = MeshPyramid;const MeshPyramid2 = MeshPyramid;const Box3 = Box;class Base extends Box {HEADER = "base";buildMesh(mesh) {if (!this.color) {this.color = [1,1,1,1];}let baseColor = [1,1,0];switch(this.color[0]){case 1:baseColor = [1,0,0];break;case 2:baseColor = [0,1,0];break;case 3:baseColor = [0,0,1];break;case 4:baseColor = [0.8,0,1];break;}this.color = [...baseColor,this.color[3]];super.buildMesh(mesh);}}const Base1 = Base;const Base2 = Base;const MapObject1 = MapObject;class Define extends MapObject {HEADER = "define";id = "";children = [];constructor(line3){super(line3);if (!line3) {return;}this.id = line3.split(" ")[1];}buildMesh() {}toString() {let ret = super.toString().split("\n");ret[0] += ` ${this.id}`;ret = ret.filter((line4)=>!line4.endsWith(`id ${this.id}`) && !line4.endsWith("children"));return ret.join("\n") + "def";}parseLine(line) {if (line === "box") {this.children.push(new Box(line));} else if (line === "meshbox") {this.children.push(new MeshBox(line));} else if (line === "pyramid") {this.children.push(new Pyramid(line));} else if (line === "meshpyr") {this.children.push(new MeshPyramid(line));} else if (line === "base") {this.children.push(new Base(line));} else if (this.children.length > 0) {this.children[this.children.length - 1].parseLine(line);}}}const Box4 = Box;class Zone extends Box {HEADER = "zone";color = [1,1,0,0.5];buildMesh(mesh) {super.buildMesh(mesh);}parseLine(line) {if (line.split(" ")[0] === "color") {return;}super.parseLine(line);}}const WALL_HEIGHT = 6.15;const parseNum2 = parseNum;const MapObject2 = MapObject;class World extends MapObject {HEADER = "world";vertexCount = 60;size = 400;flagHeight = 10;noWalls = false;freeCtfSpawns = false;buildMesh(mesh) {const { size  } = this;mesh.vertices.push(size, 0, size);mesh.vertices.push(size, 0, -size);mesh.vertices.push(-size, 0, -size);mesh.vertices.push(-size, 0, size);this.pushIndices(mesh);this.pushColors(mesh, 4, 0.3, 0.75, 0.3);if (!this.noWalls) {mesh.vertices.push(-size, 6.15, -size);mesh.vertices.push(-size, 0, -size);mesh.vertices.push(size, 0, -size);mesh.vertices.push(size, 6.15, -size);this.pushIndices(mesh);this.pushColors(mesh, 4, 0.5, 0.5, 0.5);mesh.vertices.push(size, 0, size);mesh.vertices.push(-size, 0, size);mesh.vertices.push(-size, 6.15, size);mesh.vertices.push(size, 6.15, size);this.pushIndices(mesh);this.pushColors(mesh, 4, 0.5, 0.5, 0.5);mesh.vertices.push(-size, 6.15, size);mesh.vertices.push(-size, 0, size);mesh.vertices.push(-size, 0, -size);mesh.vertices.push(-size, 6.15, -size);this.pushIndices(mesh);this.pushColors(mesh, 4, 0.5, 0.5, 0.5);mesh.vertices.push(size, 0, -size);mesh.vertices.push(size, 0, size);mesh.vertices.push(size, 6.15, size);mesh.vertices.push(size, 6.15, -size);this.pushIndices(mesh);this.pushColors(mesh, 4, 0.5, 0.5, 0.5);}}parseLine(line) {super.parseLine(line);const parts = line.split(" ");if (parts[0] === "size") {this.size = parseNum(parts[1]) || 400;} else if (parts[0] === "flagHeight") {this.flagHeight = parseNum(parts[1]) || 10;} else if (parts[0] === "noWalls") {this.noWalls = true;} else if (parts[0] === "freeCtfSpawns") {this.freeCtfSpawns = true;}}}const Group1 = Group;const Define1 = Define;const Zone1 = Zone;const World1 = World;function saveMap() {saveFile(`${map.objects.find((object)=>object instanceof World)?.name || "map"}.bzw`, source);}function deleteHighlightElement() {const highlighter = editor.children.item(1);if (highlighter) {highlighter.remove();}}const HEADERS = ["world","options","waterLevel","dynamicColor","textureMatrix","material","transform","physics","arc","base","box","cone","define","group","link","meshbox","meshpyr","mesh","pyramid","sphere","teleporter","tetra","weapon","zone","face","endface","enddef","drawInfo","lod","end",];const HEADERS_REGEX = new RegExp(`^([ \t]*)(${HEADERS.join("|")})`, "gm");const KEYWORDS = ["position","pos","size","rotation","rot","color","name","flagHeight","from","to","noWalls","freeCtfSpawns","height","materials","red","green","blue","alpha","center","fixedscale","scale","fixedspin","spin","fixedshift","shift","linear","angular","slide","death","passable","drivethrough","shootthrough","ricochet","oncap","border","from","to","tilt","initdelay","delay","type","trigger","eventteam","zoneflag","flag","safety",];const KEYWORDS_REGEX = new RegExp(`^([ \t]*)(${KEYWORDS.join("|")})`, "gm");const FLAGS = ["good","bad","R*","G*","B*","P*","A","BU","CS","CL","GM","G","IB","ID","JP","LG","L","MG","MQ","N","OO","PZ","QT","F","R","SE","SH","SW","ST","SR","SB","TH","T","US","V","WG","BY","B","CB","FO","JM","LT","M","NJ","O","RC","RO","RT","TR","WA",];const FLAGS_REGEX = new RegExp(`^([ \t]*(zoneflag|flag|type) )(${FLAGS.join("|").replace(/\*/g, "\\*")})`, "gm");function highlightSpan(type) {return `<span class="${type}">$1</span>`;}function highlightWord(type, first = 1, second = 2) {return `$${first}<span class="${type}">$${second}</span>`;}function highlightHtml(text) {return text.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/([-\.*/"=]+?)/g, highlightSpan("symbol")).replace(/(#.*?$)/gm, highlightSpan("comment")).replace(/([0-9]+)/g, highlightSpan("number")).replace(FLAGS_REGEX, highlightWord("flag", undefined, 3)).replace(HEADERS_REGEX, highlightWord("header")).replace(KEYWORDS_REGEX, highlightWord("keyword"));}function highlight(source1) {const lines = textarea.value.split("\n");const sourceLines = source1 ? source1.split("\n").length : lines.length;const reset = Math.abs(sourceLines - lines.length) > 1;if (reset) {deleteHighlightElement();}if (!editor.children.item(1)) {const highlightElement = document.createElement("pre");if (!highlightElement) {console.error("highlight element could not be created");return;}highlightElement.classList.add("highlight");const html = (highlightHtml(textarea.value) + "\n").split("\n");for(const lineNumber in html){const line2 = document.createElement("div");line2.innerHTML = html[lineNumber];highlightElement.appendChild(line2);}editor.appendChild(highlightElement);highlightElement.scrollTop = textarea.scrollTop;highlightElement.scrollLeft = textarea.scrollLeft;}if (reset) {return;}const elem = editor.children.item(1);if (!elem) {return;}const selectionStart = textarea.selectionStart;const currentLineNumber = (sourceLines === lines.length ? textarea.value : source1 ?? "").substr(0, selectionStart).split("\n").length - 1;const html = highlightHtml(lines[currentLineNumber]);if (sourceLines < lines.length) {const newLine = document.createElement("div");newLine.innerHTML = highlightHtml(lines[currentLineNumber + 1]);elem.insertBefore(newLine, elem.children[currentLineNumber + 1]);} else if (sourceLines > lines.length) {elem.removeChild(elem.children[currentLineNumber]);}elem.children[currentLineNumber].innerHTML = html;}function _textareaChanged(shouldParseSource = true, forceHighlightUpdate = false) {if (trimText(textarea.value) === trimText(source)) {return;}if (settings.syntaxHighlighting.checked) {if (forceHighlightUpdate) {deleteHighlightElement();}highlight(source);}source = textarea.value;updateLineNumbers();if (shouldParseSource) {parseSource();}updateMesh();localStorage.setItem("bzw", source);}let timeoutId = 0;function textareaChanged(shouldParseSource = true, forceHighlightUpdate = false) {if (timeoutId) {clearTimeout(timeoutId);}timeoutId = setTimeout(()=>_textareaChanged(shouldParseSource, forceHighlightUpdate), 15);}function setColorTheme(e) {if (!e) {return;}const target = e.target;if (target.classList.contains("menu")) {return;}localStorage.setItem("colorTheme", target.innerText.toLowerCase().replace(/ /g, "-"));colorThemeChanged();}setColorTheme();function syntaxHighlightingChanged() {if (settings.syntaxHighlighting.checked) {textarea.classList.remove("show");highlight();} else {textarea.classList.add("show");deleteHighlightElement();}}settings.autoRotate.addEventListener("change", ()=>{localStorage.setItem("autoRotate", settings.autoRotate.checked ? "true" : "false");});settings.showAxis.addEventListener("change", ()=>{localStorage.setItem("showAxis", settings.showAxis.checked ? "true" : "false");});settings.syntaxHighlighting.addEventListener("change", ()=>{localStorage.setItem("syntaxHighlighting", settings.syntaxHighlighting.checked ? "true" : "false");syntaxHighlightingChanged();});bzwFile.addEventListener("change", ()=>{handleFile(bzwFile.files);});textarea.oninput = ()=>textareaChanged();textarea.addEventListener("scroll", ()=>{const highlighter = editor.children.item(1);if (highlighter) {highlighter.scrollTop = textarea.scrollTop;highlighter.scrollLeft = textarea.scrollLeft;}lineNumbersElement.scrollTop = textarea.scrollTop;});function toggleComment() {textarea.focus();let selectionStart = textarea.selectionStart;const currentLineNumber = textarea.value.substr(0, selectionStart).split("\n").length - 1;const lines = textarea.value.split("\n");if (lines[currentLineNumber].startsWith("#")) {lines[currentLineNumber] = lines[currentLineNumber].substr(1);selectionStart--;} else {lines[currentLineNumber] = "#" + lines[currentLineNumber];selectionStart++;}textarea.value = lines.join("\n");textarea.selectionEnd = selectionStart;}textarea.onkeydown = (e)=>{if (e.keyCode === 191 && e.ctrlKey) {e.preventDefault();toggleComment();textareaChanged();}};let selectedMapObjectIndex = 0;function mapToBZW(map1) {return map1.objects.map((object)=>object.toString()).join("\n\n");}function cleanLine(line2) {if (line2.includes("#")) {line2 = line2.substring(0, line2.indexOf("#"));}line2 = line2.trim().replace(/ +(?= )/g, "");return line2;}function parse(source1) {const map1 = {worldSize: 400,objects: []};let current = "";for (let line2 of source1.split("\n")){line2 = cleanLine(line2);if (line2[0] === "#") {continue;}if (current === "define") {if (line2 === "enddef") {current = "";continue;}map1.objects[map1.objects.length - 1].parseLine(line2);continue;}if (line2 === "end") {current = "";} else if (line2 === "world") {current = line2;map1.objects.push(new World(line2));} else if (line2 === "box") {current = line2;map1.objects.push(new Box(line2));} else if (line2 === "meshbox") {current = line2;map1.objects.push(new MeshBox(line2));} else if (line2 === "pyramid") {current = line2;map1.objects.push(new Pyramid(line2));} else if (line2 === "meshpyr") {current = line2;map1.objects.push(new MeshPyramid(line2));} else if (line2 === "base") {current = line2;map1.objects.push(new Base(line2));} else if (line2 === "zone") {current = line2;map1.objects.push(new Zone(line2));} else if (line2.startsWith("define")) {current = "define";map1.objects.push(new Define(line2));} else if (line2.startsWith("group")) {current = "group";map1.objects.push(new Group(line2));} else {switch(current){case "world":case "box":case "meshbox":case "pyramid":case "meshpyr":case "base":case "zone":case "define":case "group":map1.objects[map1.objects.length - 1].parseLine(line2);if (current === "world" && line2.startsWith("size")) {map1.worldSize = map1.objects[map1.objects.length - 1].size;}break;default: break;}}}for (const object of map1.objects){if (object instanceof Group) {object.define = map1.objects.find((otherObject)=>otherObject instanceof Define && otherObject.id === object.id);}}return map1;}function setSelectedMapObject(newIndex) {if (newIndex === selectedMapObjectIndex) {return;}selectedMapObjectIndex = newIndex;if (selectedMapObjectIndex < 0) {tree.properties.style.display = "none";return;}const selectedMapObject = map.objects[selectedMapObjectIndex];removeAllChildren(tree.properties);const typeElement = document.createElement("div");typeElement.innerText = `type: ${selectedMapObject.HEADER}`;tree.properties.appendChild(typeElement);const properties = Object.keys(selectedMapObject);const values = Object.values(selectedMapObject);for(const i in properties){const property = properties[i];const value = values[i];if (["vertexCount","HEADER"].includes(property)) {continue;}if (selectedMapObject.HEADER === "zone" && property === "color" || selectedMapObject.HEADER === "group" && property === "position") {continue;}const nameElement = document.createElement("span");nameElement.innerText = property;tree.properties.appendChild(nameElement);const valueElement = document.createElement("div");const createInputElement = (type, value1, changedHandler)=>{const inputElement = document.createElement("input");inputElement.type = type;inputElement.spellcheck = false;if (type === "checkbox") {inputElement.checked = value1;} else {inputElement.value = value1;}inputElement.addEventListener("input", ()=>{if (selectedMapObjectIndex === -1) {return;}changedHandler(inputElement);textarea.value = mapToBZW(map);textareaChanged(undefined, true);});valueElement.appendChild(inputElement);};switch(typeof value){case "string":{createInputElement("text", value, (inputElement)=>{map.objects[selectedMapObjectIndex][property] = inputElement.value;});}break;case "number":{createInputElement("number", `${value}`, (inputElement)=>{map.objects[selectedMapObjectIndex][property] = parseNum(inputElement.value);});}break;case "boolean":{createInputElement("checkbox", value, (inputElement)=>{map.objects[selectedMapObjectIndex][property] = inputElement.checked;});}break;case "undefined":{const createElement = document.createElement("button");createElement.classList.add("btn");createElement.innerText = "Edit";createElement.addEventListener("click", ()=>{if (selectedMapObjectIndex === -1) {return;}if (property === "color") {map.objects[selectedMapObjectIndex][property] = [0,0,0,1];textarea.value = mapToBZW(map);textareaChanged(undefined, true);const index = parseInt(`${selectedMapObjectIndex}`);selectedMapObjectIndex = -1;setSelectedMapObject(index);} else {alert("something somewhere is messed up big time");}});valueElement.appendChild(createElement);}break;case "object":{if (Array.isArray(value) && typeof value[0] === "number") {for(const valueIndex in value){createInputElement("number", `${value[valueIndex]}`, (inputElement)=>{map.objects[selectedMapObjectIndex][property][valueIndex] = parseNum(inputElement.value);});}if (property === "color") {const deleteElement = document.createElement("button");deleteElement.classList.add("btn");deleteElement.innerText = "Reset";deleteElement.addEventListener("click", ()=>{if (selectedMapObjectIndex === -1) {return;}if (property === "color") {map.objects[selectedMapObjectIndex][property] = undefined;textarea.value = mapToBZW(map);textareaChanged(undefined, true);const index = parseInt(`${selectedMapObjectIndex}`);selectedMapObjectIndex = -1;setSelectedMapObject(index);} else {alert("something somewhere is messed up big time");}});valueElement.appendChild(deleteElement);}} else {valueElement.innerText = "unsupported property";}}break;default:valueElement.innerText = "unsupported property";break;}tree.properties.appendChild(valueElement);}tree.properties.style.display = "flex";}tree.objects.addEventListener("click", (e)=>{const target = e.target;if (!target || !target.parentElement || !target.parentElement.classList.contains("objects")) {return;}for (const selected of tree.objects.querySelectorAll(".selected")){selected.classList.remove("selected");}target.classList.add("selected");const index = Array.from(target.parentElement.children).indexOf(target);setSelectedMapObject(index);});window.addEventListener("dragenter", (e)=>{e.stopPropagation();e.preventDefault();});window.addEventListener("dragover", (e)=>{e.stopPropagation();e.preventDefault();});window.addEventListener("drop", (e)=>{e.stopPropagation();e.preventDefault();handleFile(e.dataTransfer?.files);});window.onkeydown = (e)=>{if (e.keyCode === 83 && e.ctrlKey) {e.preventDefault();saveMap();} else if (e.keyCode === 79 && e.ctrlKey) {e.preventDefault();bzwFile.click();}};document.addEventListener("DOMContentLoaded", ()=>{settings.autoRotate.checked = localStorage.getItem("autoRotate") === "true";settings.showAxis.checked = localStorage.getItem("showAxis") !== "false";settings.syntaxHighlighting.checked = localStorage.getItem("syntaxHighlighting") !== "false";parseSource();updateMesh();setTimeout(()=>{updateLineNumbers();deleteHighlightElement();syntaxHighlightingChanged();});});function parseSource() {const oldSelected = map.objects[selectedMapObjectIndex]?.toString() ?? "";map = parse(source);removeAllChildren(tree.objects);for (const object of map.objects){const div = document.createElement("div");div.innerText = object.name || object.HEADER;tree.objects.appendChild(div);}if (selectedMapObjectIndex >= map.objects.length) {setSelectedMapObject(-1);} else if ((map.objects[selectedMapObjectIndex]?.toString() ?? "") !== oldSelected) {const index = parseInt(`${selectedMapObjectIndex}`);selectedMapObjectIndex = -1;setSelectedMapObject(index);}}function updateMesh() {const mesh = {vertices: [],indices: [],colors: [],indicesCount: 0};if (!map.objects.find((object)=>object instanceof World)) {map.objects.push(new World());map.worldSize = map.objects[map.objects.length - 1].size;}for (const object of [...map.objects].sort((a, b)=>(a.color?.[3] ?? -1) > (b.color?.[3] ?? 1) ? 1 : -1)){object.buildMesh(mesh);}renderer.worldSize = map.worldSize;renderer.updateMesh(mesh);statusBar.objects.innerText = `${map.objects.length} Objects`;statusBar.vertices.innerText = `${mesh.indices.length} Vertices`;}const canvasParent = canvas.parentElement;window.addEventListener("resize", ()=>{if (!canvasParent) {return;}const parentWidth = canvasParent.getBoundingClientRect().width;const minWidth = parentWidth / 2;const maxWidth = parentWidth - parentWidth / 4;let newRightWidth = canvas.width;if (newRightWidth < minWidth) {newRightWidth = minWidth;} else if (newRightWidth > maxWidth) {newRightWidth = maxWidth;}canvas.width = newRightWidth;});</script>
</body>
</html>
