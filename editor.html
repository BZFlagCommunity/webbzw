<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%22256%22 height=%22256%22 viewBox=%220 0 100 100%22><rect width=%22100%22 height=%22100%22 rx=%2220%22 fill=%22%23000000%22></rect><path d=%22M9.46 72.40L9.46 27.60L20.08 27.60Q25.52 27.60 28.02 30.13Q30.51 32.66 30.51 37.90L30.51 37.90L30.51 39.70Q30.51 43.15 29.39 45.33Q28.27 47.50 25.97 48.46L25.97 48.46L25.97 48.59Q31.22 50.38 31.22 57.94L31.22 57.94L31.22 61.78Q31.22 66.96 28.50 69.68Q25.78 72.40 20.53 72.40L20.53 72.40L9.46 72.40ZM16.50 45.84L19.25 45.84Q21.36 45.84 22.42 44.75Q23.47 43.66 23.47 41.10L23.47 41.10L23.47 38.61Q23.47 36.18 22.61 35.09Q21.74 34.00 19.89 34.00L19.89 34.00L16.50 34.00L16.50 45.84ZM16.50 66L20.53 66Q22.38 66 23.28 65.01Q24.18 64.02 24.18 61.58L24.18 61.58L24.18 57.68Q24.18 54.61 23.12 53.42Q22.06 52.24 19.63 52.24L19.63 52.24L16.50 52.24L16.50 66ZM33.90 72.40L33.90 66.13L46.96 34.00L34.54 34.00L34.54 27.60L54.51 27.60L54.51 33.87L41.46 66L54.51 66L54.51 72.40L33.90 72.40ZM61.36 72.40L56.82 27.60L63.60 27.60L66.74 62.03L66.86 62.03L70.19 27.60L77.87 27.60L81.20 62.03L81.33 62.03L84.46 27.60L90.54 27.60L86 72.40L77.23 72.40L74.03 42.19L73.90 42.19L70.70 72.40L61.36 72.40Z%22 fill=%22%23fff%22></path></svg>">
  <title>Web BZW</title>
  <style>@import url("https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;900&display=swap");*{color:var(--text-color);box-sizing:border-box;-webkit-tap-highlight-color:transparent;}:root{font-size:18px;--shadow-color:rgba(0, 0, 0, .05);--shadow-height:.2rem;--shadow-spread:.5rem;--scrollbar-size:.5rem;--border-radius:.25rem;--transition-duration:.1s;/* color theme */--background-color:#17171C;--border-color:#27272F;--text-color:#FFF;--text-light-color:#BBB;--selection-color:rgba(255, 255, 255, .2);}:root[data-theme=high-contrast]{--background-color:#000;--border-color:#777;--text-light-color:#FFF;--selection-color:rgba(255, 255, 255, .3);}:root[data-theme=one-dark-pro]{--background-color:#282C34;--border-color:#454C5A;}:root[data-theme=one-half-light]{--background-color:#FFF;--border-color:#EEE;--text-color:#000;--text-light-color:#444;--selection-color:rgba(0, 0, 0, .2);}:root[data-theme=palenight]{--background-color:#292D3E;--border-color:#424864;--selection-color:#7580B850;}:root[data-theme=one-monokai]{--background-color:#282C34;--border-color:#454C5A;}body{height:100vh;margin:0;background-color:var(--background-color);font-family:Montserrat, sans-serif;display:flex;flex-direction:column;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}.welcome{width:100%;text-align:center;flex:1;align-self:center;display:flex;flex-direction:column;justify-content:center;}.welcome h1{font-size:2rem;font-weight:900;text-transform:uppercase;}.welcome a{padding:1rem 2rem;background-color:#0FA;color:#FFF;font-weight:900;text-decoration:none;text-transform:uppercase;align-self:center;border-radius:var(--border-radius);box-shadow:0 0 1rem #0FA8;transition:all var(--transition-duration) ease-in-out;}.welcome a:hover{transform:translate3d(0, -.1rem, 0);box-shadow:0 0 1.1rem #0FA;}.maps{margin:6rem 0;display:grid;grid-template-columns:repeat(auto-fit, 20rem);grid-auto-rows:10rem;grid-gap:1rem;justify-content:center;}.maps > div{padding:.5rem;background-color:var(--border-color);display:flex;justify-content:center;align-items:center;border-radius:var(--border-radius);box-shadow:0 .2rem 1rem rgba(0, 0, 0, .1);cursor:pointer;transition:all var(--transition-duration) ease-in-out;}.maps > div:hover{transform:translate3d(0, -.1rem, 0);box-shadow:0 .5rem 1.5rem rgba(0, 0, 0, .2);}h1{margin:0;line-height:1em;}input[type=file]{display:none;}input[type=checkbox]{cursor:pointer;}header{padding:0 .5rem;background-color:var(--border-color);display:flex;flex-direction:row;align-items:center;border-bottom:2px solid #000;z-index:9;}header > svg{margin-right:1rem;fill:var(--text-color);cursor:pointer;}nav{display:flex;}nav input[type=checkbox]{margin-right:.5rem;}nav a{text-decoration:none;flex:1;}nav > div{font-size:.9rem;user-select:none;}nav > div:hover, nav .menu > span:hover{background-color:var(--selection-color);}nav > .parent > span{padding:.2rem .5rem;display:block;}nav .parent{position:relative;}nav .parent:hover > .menu{display:flex;}nav .menu{width:15rem;padding:.2rem 0;background-color:var(--background-color);position:absolute;display:none;flex-direction:column;border:1px solid var(--border-color);box-shadow:0 var(--shadow-height) var(--shadow-spread) var(--shadow-color);cursor:default;z-index:9;}nav .menu.submenu{margin-top:-1px;margin-left:-2px;top:-.2rem;left:15rem;}nav > .menu:not(.submenu){border-top:none;}nav .menu > span{padding:.3rem .5rem;font-size:.85rem;display:flex;align-items:center;cursor:pointer;}nav .shortcut{padding-left:1rem;font-size:.8em;font-family:"Source Code Pro", monospace;text-align:right;flex:1;opacity:.75;}footer{padding:.25rem .5rem;background-color:var(--border-color);font-size:.7rem;display:flex;border-top:2px solid #000;box-shadow:0 calc(var(--shadow-height) * -1) var(--shadow-spread) var(--shadow-color);z-index:1;}footer > span:not(:last-child){margin-right:1rem;}main{min-height:0;flex:1;display:grid;grid-template-columns:20rem 1fr;grid-template-rows:auto;}@media only screen and (max-width:1200px){main{grid-template-columns:15rem 1fr;}}pre{margin:0;}select{padding:.2rem;background-color:var(--background-color);font-family:Montserrat, sans-serif;font-size:.8rem;font-weight:500;border:none;border-radius:var(--border-radius);outline:none;cursor:pointer;}.panel{padding:.2rem .5rem;display:flex;flex-direction:column;border:2px solid #000;overflow:auto;}.panel svg{stroke:var(--text-color);}.panel__header{margin-bottom:.5rem;font-size:.9rem;font-weight:500;display:flex;align-items:center;cursor:grab;}.panel__header > svg{margin-left:.75rem;}.panel__actions{margin-bottom:.5rem;}.panel__actions > svg{cursor:pointer;}.panel__actions > svg:not(:last-child){margin-right:.5rem;}.panel__content{display:flex;flex-direction:column;flex:1;overflow:auto;}.panel__content::-webkit-scrollbar{width:var(--scrollbar-size);height:var(--scrollbar-size);}.panel__content::-webkit-scrollbar-thumb{background:var(--border-color);border-radius:var(--scrollbar-size);}.panel__content::-webkit-scrollbar-thumb:hover{background:var(--text-color);}.btn{padding:.2rem .5rem;background:none;font-size:.8rem;font-family:"Source Code Pro", monospace;border:1px solid var(--border-color);border-radius:var(--border-radius);outline:none;cursor:pointer;}.btn:hover{background-color:var(--border-color);}#objects{grid-column:1;grid-row:1;}#objects > .panel__content{font-size:.8rem;font-family:"Source Code Pro", monospace;line-height:1em;user-select:none;}#objects > .panel__content > div{padding:.1rem;color:var(--text-light-color);cursor:pointer;}#objects > .panel__content > div.selected,#objects > .panel__content > div:hover{color:var(--text-color);}#properties{grid-column:1;grid-row:2;}#properties > .panel__content{font-size:.8rem;}#properties > .panel__content > div{display:flex;flex-direction:row;align-items:center;}#properties > .panel__content > div:not(:last-child){margin-bottom:.5rem;}#properties > .panel__content > div > *:not(input[type=checkbox]){flex:1;}#properties > .panel__content > div > *:not(:last-child){margin-right:.2rem;}#properties > .panel__content input{padding:.2rem .5rem;background:none;font-family:"Source Code Pro", monospace;font-size:.8rem;border:1px solid var(--border-color);border-radius:var(--border-radius);outline:none;}#properties > .panel__content input:not([type=checkbox]){width:100%;}#preview{grid-column:2;grid-row:1 / 3;}#preview canvas{min-height:100px;flex:1;}</style>
</head>
<body>
  <header>
    <svg onclick="window.location.href = '/'" width="20" height="21" viewBox="0 0 20 21" xmlns="http://www.w3.org/2000/svg"><path d="M20 11.5091L10 0.6L0 11.5091H3.55795V20.6H8.17675V15.1455H11.8718V20.6H16.4906V11.5091H20Z"/></svg>
    <nav>
      <div class="parent">
        <span>File</span>
        <div class="menu">
          <span onclick="window.location.href = '/editor'">
            New
          </span>
          <span onclick="bzwFile.click()">
            Open
            <span class="shortcut">Ctrl+O</span>
          </span>
          <span onclick="saveMap()">
            Download
            <span class="shortcut">Ctrl+D</span>
          </span>
          <span onclick="deleteMap()">
            Delete
            <span class="shortcut">Ctrl+Shift+D</span>
          </span>
        </div>
      </div>
      <div class="parent">
        <span>Edit</span>
        <div class="menu">
          <span class="parent">
            Object
            <span class="shortcut">&gt;</span>
            <div class="menu submenu">
              <span onclick="addObject(prompt('Type of object:'))">
                Add
                <span class="shortcut">Alt+A</span>
              </span>
              <span onclick="removeObject()">
                Remove
                <span class="shortcut">Alt+R</span>
              </span>
            </div>
          </span>
        </div>
      </div>
      <div class="parent">
        <span>View</span>
        <div class="menu">
          <span onclick="settings.autoRotate.click()">
            <input type="checkbox" id="auto-rotate" onclick="event.stopPropagation()">
            Auto Rotate
          </span>
          <span onclick="settings.showAxis.click()">
            <input type="checkbox" id="show-axis" onclick="event.stopPropagation()">
            Show Axis
          </span>
          <span class="parent">
            Color Theme
            <span class="shortcut">&gt;</span>
            <div class="menu submenu" onclick="setColorTheme(event)">
              <span>Default</span>
              <span>High Contrast</span>
              <span>One Dark Pro</span>
              <span>One Half Light</span>
              <span>Palenight</span>
              <span>One Monokai</span>
            </div>
          </span>
        </div>
      </div>
      <div class="parent">
        <span>Help</span>
        <div class="menu">
          <span><a href="https://github.com/BZFlagCommunity/webbzw/issues/new?labels=bug" target="_blank" rel="noopener noreferrer">Report a Bug</a></span>
          <span><a href="https://github.com/BZFlagCommunity/webbzw/releases/v0.3.4" target="_blank" rel="noopener noreferrer">v0.3.4</a></span>
        </div>
      </div>
    </nav>
    <input type="file" id="bzw-file" accept=".bzw">
  </header>
  <main>
    <div class="panel" id="objects">
      <div class="panel__header">
        Objects
        <svg onclick="alert('not implemented yet')" width="10" height="8" viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><line y1="1" x2="10" y2="1"/><line y1="4" x2="10" y2="4"/><line y1="7" x2="10" y2="7"/></svg>
      </div>
      <div class="panel__actions">
        <svg onclick="addObject(prompt('Type of object:'))" width="9" height="9" viewBox="0 0 9 9" xmlns="http://www.w3.org/2000/svg" title="Add Object"><line y1="4.5" x2="9" y2="4.5"/><line x1="4.5" y1="9" x2="4.5"/></svg>
        <svg onclick="removeObject()" width="9" height="9" viewBox="0 0 9 9" xmlns="http://www.w3.org/2000/svg" title="Remove Object"><line y1="4.5" x2="9" y2="4.5"/></svg>
      </div>
      <div class="panel__content"></div>
    </div>
    <div class="panel" id="properties">
      <div class="panel__header">
        Properties
        <svg onclick="alert('not implemented yet')" width="10" height="8" viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><line y1="1" x2="10" y2="1"/><line y1="4" x2="10" y2="4"/><line y1="7" x2="10" y2="7"/></svg>
      </div>
      <div class="panel__content"></div>
    </div>
    <div class="panel" id="preview">
      <div class="panel__header">
        Preview
        <svg onclick="alert('not implemented yet')" width="10" height="8" viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><line y1="1" x2="10" y2="1"/><line y1="4" x2="10" y2="4"/><line y1="7" x2="10" y2="7"/></svg>
      </div>
      <div class="panel__content">
        <canvas></canvas>
      </div>
    </div>
  </main>
  <footer>
    <span id="status--objects"></span>
    <span id="status--vertices"></span>
    <span style="flex:1"></span>
    <span><a href="https://github.com/BZFlagCommunity/webbzw" target="_blank" rel="noopener noreferrer">GitHub</a></span>
    <span>Copyright &copy; 2021 <a href="https://thenoah.dev" target="_blank" rel="noopener noreferrer">The Noah</a></span>
  </footer>
  <script>function getProjection(angle, aspectRatio, zMin, zMax) {const ang = Math.tan(angle * 0.5 * Math.PI / 180);return [0.5 / ang,0,0,0,0,0.5 * aspectRatio / ang,0,0,0,0,-(zMax + zMin) / (zMax - zMin),-1,0,0,-2 * zMax * zMin / (zMax - zMin),0];}function multiplyMatrices(a, b) {const result = [];const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];result[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;result[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;result[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;result[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;b0 = b[4];b1 = b[5];b2 = b[6];b3 = b[7];result[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;result[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;result[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;result[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;b0 = b[8];b1 = b[9];b2 = b[10];b3 = b[11];result[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;result[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;result[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;result[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;b0 = b[12];b1 = b[13];b2 = b[14];b3 = b[15];result[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;result[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;result[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;result[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;return result;}function multiplyArrayOfMatrices(matrices) {let inputMatrix = matrices[0];for(let i = 1; i < matrices.length; i++){inputMatrix = multiplyMatrices(inputMatrix, matrices[i]);}return inputMatrix;}function rotateXMatrix(angle) {angle *= Math.PI / 180;return [1,0,0,0,0,Math.cos(angle),-Math.sin(angle),0,0,Math.sin(angle),Math.cos(angle),0,0,0,0,1];}function rotateYMatrix(angle) {angle *= Math.PI / 180;return [Math.cos(angle),0,Math.sin(angle),0,0,1,0,0,-Math.sin(angle),0,Math.cos(angle),0,0,0,0,1];}function rotY(position, angle) {const s = Math.sin(angle);const c = Math.cos(angle);let x = 0, z = 0;z = position[2] * c - position[0] * s;x = position[2] * s + position[0] * c;return [x,position[1],z];}const INDENT = "  ";function parseNum(str, fallback = 0) {const value = parseFloat(str);if (isNaN(value)) {return fallback;}return value;}class MapObject {vertexCount = 0;name = "";constructor(line1){}toString() {let ret = `${this.HEADER}\n`;const properties = Object.keys(this);const values = Object.values(this);for(const i in properties){const property = properties[i];let value = values[i];if (["vertexCount","HEADER"].includes(property)) {continue;}if (!value || Array.isArray(value) && value.filter((val)=>val).length === 0) {continue;}if (this.HEADER === "zone" && property === "color" || this.HEADER === "group" && property === "position") {continue;}ret += `${INDENT}${property}`;if (typeof value === "number" || typeof value === "string") {ret += ` ${value}`;} else if (typeof value === "object" && Array.isArray(value) && typeof value[0] !== "object") {ret += ` ${value.join(" ")}`;} else if (typeof value === "object" && Array.isArray(value) && typeof value[0] === "object") {value = value.map((val)=>val.toString().split("\n").map((line1)=>`${INDENT}${line1}`).join("\n"));ret += `\n${value.join("\n\n")}`;}ret += "\n";}ret += "end";return ret;}parseLine(line) {const parts = line.split(" ");if (parts[0] === "name") {this.name = parts.slice(1).join(" ");}}pushIndices(mesh) {mesh.indices.push(mesh.indicesCount);mesh.indices.push(mesh.indicesCount + 1);mesh.indices.push(mesh.indicesCount + 2);mesh.indices.push(mesh.indicesCount + 2);mesh.indices.push(mesh.indicesCount + 3);mesh.indices.push(mesh.indicesCount);mesh.indicesCount += 4;}pushColors(mesh, count = 1, r = 0, g = 0, b = 0, a = 1) {for(let i = 0; i < count; i++){mesh.colors.push(r, g, b, a);}}}class VeryBasicMapObject extends MapObject {position = [0,0,0];rotation = 0;shift = [0,0,0];parseLine(line) {super.parseLine(line);const parts = line.split(" ");if (parts[0] === "position") {this.position = [parseNum(parts[1]),parseNum(parts[2]),parseNum(parts[3])];} else if (parts[0] === "shift") {this.shift = [parseNum(parts[1]),parseNum(parts[2]),parseNum(parts[3])];} else if (parts[0] === "rotation") {this.rotation = parseNum(parts[1]);}}applyRotPosShift(mesh) {if (this.vertexCount === 0) {return;}this.applyRotation(mesh);for(let i = mesh.vertices.length - this.vertexCount; i < mesh.vertices.length; i += 3){mesh.vertices[i] += this.position[0] + this.shift[0];}for(let i1 = mesh.vertices.length - (this.vertexCount - 1); i1 < mesh.vertices.length; i1 += 3){mesh.vertices[i1] += this.position[2] + this.shift[2];}for(let i2 = mesh.vertices.length - (this.vertexCount - 2); i2 < mesh.vertices.length; i2 += 3){mesh.vertices[i2] -= this.position[1] + this.shift[1];}}applyRotation(mesh) {if (this.vertexCount === 0) {return;}const _rotation = this.rotation * Math.PI / 180;for(let i = mesh.vertices.length - this.vertexCount; i < mesh.vertices.length; i += 3){const rot = rotY([mesh.vertices[i],mesh.vertices[i + 1],mesh.vertices[i + 2]], _rotation);mesh.vertices[i] = rot[0];mesh.vertices[i + 1] = rot[1];mesh.vertices[i + 2] = rot[2];}}}class BasicMapObject extends VeryBasicMapObject {size = [10,10,10];color = undefined;parseLine(line) {super.parseLine(line);const parts = line.split(" ");if (parts[0] === "size") {this.size = [parseNum(parts[1], 0.5),parseNum(parts[2], 0.5),parseNum(parts[3], 1)];if (parseFloat(parts[3]) === 0) {this.size[2] = 0.01;}} else if (parts[0] === "color") {this.color = [parseNum(parts[1], 1),parseNum(parts[2], 1),parseNum(parts[3], 1),parseNum(parts[4], 1)];}}}class BoxLike extends BasicMapObject {vertexCount = 72;buildMesh(mesh) {let { size , color  } = this;let defaultColor = false;if (!color) {defaultColor = true;color = [0.61,0.26,0.12,1];}mesh.vertices.push(-size[0], size[2], -size[1]);mesh.vertices.push(-size[0], size[2], size[1]);mesh.vertices.push(size[0], size[2], size[1]);mesh.vertices.push(size[0], size[2], -size[1]);this.pushIndices(mesh);mesh.vertices.push(size[0], 0, -size[1]);mesh.vertices.push(size[0], 0, size[1]);mesh.vertices.push(-size[0], 0, size[1]);mesh.vertices.push(-size[0], 0, -size[1]);this.pushIndices(mesh);mesh.vertices.push(size[0], 0, -size[1]);mesh.vertices.push(-size[0], 0, -size[1]);mesh.vertices.push(-size[0], size[2], -size[1]);mesh.vertices.push(size[0], size[2], -size[1]);this.pushIndices(mesh);mesh.vertices.push(size[0], size[2], size[1]);mesh.vertices.push(-size[0], size[2], size[1]);mesh.vertices.push(-size[0], 0, size[1]);mesh.vertices.push(size[0], 0, size[1]);this.pushIndices(mesh);mesh.vertices.push(-size[0], 0, -size[1]);mesh.vertices.push(-size[0], 0, size[1]);mesh.vertices.push(-size[0], size[2], size[1]);mesh.vertices.push(-size[0], size[2], -size[1]);this.pushIndices(mesh);mesh.vertices.push(size[0], size[2], -size[1]);mesh.vertices.push(size[0], size[2], size[1]);mesh.vertices.push(size[0], 0, size[1]);mesh.vertices.push(size[0], 0, -size[1]);this.pushIndices(mesh);this.applyRotPosShift(mesh);if (!defaultColor) {this.pushColors(mesh, 8, color[0], color[1], color[2], color[3]);} else {this.pushColors(mesh, 8, 0.75, 0.75, 0.75, color[3]);}this.pushColors(mesh, 16, color[0], color[1], color[2], color[3]);}}class World extends MapObject {HEADER = "world";vertexCount = 60;size = 400;flagHeight = 10;noWalls = false;freeCtfSpawns = false;buildMesh(mesh) {const { size  } = this;mesh.vertices.push(size, 0, size);mesh.vertices.push(size, 0, -size);mesh.vertices.push(-size, 0, -size);mesh.vertices.push(-size, 0, size);this.pushIndices(mesh);this.pushColors(mesh, 4, 0.3, 0.75, 0.3);if (!this.noWalls) {mesh.vertices.push(-size, 6.15, -size);mesh.vertices.push(-size, 0, -size);mesh.vertices.push(size, 0, -size);mesh.vertices.push(size, 6.15, -size);this.pushIndices(mesh);this.pushColors(mesh, 4, 0.5, 0.5, 0.5);mesh.vertices.push(size, 0, size);mesh.vertices.push(-size, 0, size);mesh.vertices.push(-size, 6.15, size);mesh.vertices.push(size, 6.15, size);this.pushIndices(mesh);this.pushColors(mesh, 4, 0.5, 0.5, 0.5);mesh.vertices.push(-size, 6.15, size);mesh.vertices.push(-size, 0, size);mesh.vertices.push(-size, 0, -size);mesh.vertices.push(-size, 6.15, -size);this.pushIndices(mesh);this.pushColors(mesh, 4, 0.5, 0.5, 0.5);mesh.vertices.push(size, 0, -size);mesh.vertices.push(size, 0, size);mesh.vertices.push(size, 6.15, size);mesh.vertices.push(size, 6.15, -size);this.pushIndices(mesh);this.pushColors(mesh, 4, 0.5, 0.5, 0.5);if (false) {mesh.vertices.push(size, 0, -size);mesh.vertices.push(-size, 0, -size);mesh.vertices.push(-size, 6.15, -size);mesh.vertices.push(size, 6.15, -size);this.pushIndices(mesh);this.pushColors(mesh, 4, 0.5, 0.5, 0.5);mesh.vertices.push(-size, 6.15, size);mesh.vertices.push(-size, 0, size);mesh.vertices.push(size, 0, size);mesh.vertices.push(size, 6.15, size);this.pushIndices(mesh);this.pushColors(mesh, 4, 0.5, 0.5, 0.5);mesh.vertices.push(-size, 0, -size);mesh.vertices.push(-size, 0, size);mesh.vertices.push(-size, 6.15, size);mesh.vertices.push(-size, 6.15, -size);this.pushIndices(mesh);this.pushColors(mesh, 4, 0.5, 0.5, 0.5);mesh.vertices.push(size, 6.15, size);mesh.vertices.push(size, 0, size);mesh.vertices.push(size, 0, -size);mesh.vertices.push(size, 6.15, -size);this.pushIndices(mesh);this.pushColors(mesh, 4, 0.5, 0.5, 0.5);}}}parseLine(line) {super.parseLine(line);const parts = line.split(" ");if (parts[0] === "size") {this.size = parseNum(parts[1]) || 400;} else if (parts[0] === "flagHeight") {this.flagHeight = parseNum(parts[1]) || 10;} else if (parts[0] === "noWalls") {this.noWalls = true;} else if (parts[0] === "freeCtfSpawns") {this.freeCtfSpawns = true;}}}class Box extends BoxLike {HEADER = "box";drivethrough = false;shootthrough = false;parseLine(line) {super.parseLine(line);const parts = line.split(" ");if (parts[0] === "drivethrough") {this.drivethrough = true;} else if (parts[0] === "shootthrough") {this.shootthrough = true;}}}class MeshBox extends Box {HEADER = "meshbox";phydrv = "";parseLine(line) {super.parseLine(line);const parts = line.split(" ");if (parts[0] === "phydrv") {this.phydrv = parts.slice(1).join(" ");}}}class Base extends BoxLike {HEADER = "base";buildMesh(mesh) {if (!this.color) {this.color = [1,1,1,1];}let baseColor = [1,1,0];switch(this.color[0]){case 1:baseColor = [1,0,0];break;case 2:baseColor = [0,1,0];break;case 3:baseColor = [0,0,1];break;case 4:baseColor = [0.8,0,1];break;}this.color = [...baseColor,this.color[3]];super.buildMesh(mesh);}}const DEFAULT_COLOR = [0.1,0.3,1,1];class Pyramid extends BasicMapObject {HEADER = "pyramid";vertexCount = 48;drivethrough = false;shootthrough = false;buildMesh(mesh) {let { size , color  } = this;if (!color) {color = DEFAULT_COLOR;}mesh.vertices.push(size[0], 0, -size[1]);mesh.vertices.push(size[0], 0, size[1]);mesh.vertices.push(-size[0], 0, size[1]);mesh.vertices.push(-size[0], 0, -size[1]);this.pushIndices(mesh);mesh.vertices.push(size[0], 0, size[1]);mesh.vertices.push(0, size[2], 0);mesh.vertices.push(-size[0], 0, size[1]);this.pushIndices2(mesh);mesh.vertices.push(-size[0], 0, -size[1]);mesh.vertices.push(0, size[2], 0);mesh.vertices.push(size[0], 0, -size[1]);this.pushIndices2(mesh);mesh.vertices.push(-size[0], 0, size[1]);mesh.vertices.push(0, size[2], 0);mesh.vertices.push(-size[0], 0, -size[1]);this.pushIndices2(mesh);mesh.vertices.push(size[0], 0, -size[1]);mesh.vertices.push(0, size[2], 0);mesh.vertices.push(size[0], 0, size[1]);this.pushIndices2(mesh);this.applyRotPosShift(mesh);this.pushColors(mesh, 16, color[0], color[1], color[2], color[3]);}pushIndices2(mesh) {mesh.indices.push(mesh.indicesCount);mesh.indices.push(mesh.indicesCount + 1);mesh.indices.push(mesh.indicesCount + 2);mesh.indicesCount += 3;}parseLine(line) {super.parseLine(line);const parts = line.split(" ");if (parts[0] === "drivethrough") {this.drivethrough = true;} else if (parts[0] === "shootthrough") {this.shootthrough = true;}}}class MeshPyramid extends Pyramid {HEADER = "meshpyr";phydrv = "";parseLine(line) {super.parseLine(line);const parts = line.split(" ");if (parts[0] === "phydrv") {this.phydrv = parts.slice(1).join(" ");}}}class Zone extends BoxLike {HEADER = "zone";color = [1,1,0,0.5];parseLine(line) {if (line.split(" ")[0] === "color") {return;}super.parseLine(line);}}class Define extends MapObject {HEADER = "define";id = "";children = [];constructor(line2){super(line2);if (!line2) {return;}this.id = line2.split(" ")[1];}buildMesh() {}toString() {let ret = super.toString().split("\n");ret[0] += ` ${this.id}`;ret = ret.filter((line3)=>!line3.endsWith(`id ${this.id}`) && !line3.endsWith("children"));return ret.join("\n") + "def";}parseLine(line) {if (line === "box") {this.children.push(new Box(line));} else if (line === "meshbox") {this.children.push(new MeshBox(line));} else if (line === "pyramid") {this.children.push(new Pyramid(line));} else if (line === "meshpyr") {this.children.push(new MeshPyramid(line));} else if (line === "base") {this.children.push(new Base(line));} else if (this.children.length > 0) {this.children[this.children.length - 1].parseLine(line);}}}class Group extends VeryBasicMapObject {HEADER = "group";id = "";scale = [1,1,1];constructor(line3){super(line3);if (!line3) {return;}this.id = line3.split(" ")[1];}buildMesh(mesh) {if (!this.define || this.define.id !== this.id) {return;}for (const originalChild of this.define.children.slice()){const child = Object.create(originalChild);child.position = [child.position[0] * this.scale[0],child.position[1] * this.scale[1],child.position[2] * this.scale[2]];child.size = [child.size[0] * this.scale[0],child.size[1] * this.scale[1],child.size[2] * this.scale[2]];child.buildMesh(mesh);this.vertexCount += child.vertexCount;}super.applyRotPosShift(mesh);}toString() {let ret = super.toString().split("\n");ret[0] += ` ${this.id}`;ret = ret.filter((line4)=>!line4.endsWith(`id ${this.id}`) && !line4.endsWith("define"));return ret.join("\n");}parseLine(line) {super.parseLine(line);const parts = line.split(" ");if (parts[0] === "scale") {this.scale = [parseNum(parts[1], 1),parseNum(parts[2], 1),parseNum(parts[3], 1)];}}}class Physics extends MapObject {HEADER = "physics";slide = 0;linear = [0,0,0];buildMesh() {}parseLine(line) {super.parseLine(line);const parts = line.split(" ");if (parts[0] === "slide") {this.slide = parseNum(parts[1]) || 0;} else if (parts[0] === "linear") {this.linear = [parseNum(parts[1], 0),parseNum(parts[2], 0),parseNum(parts[3], 0)];}}}const mod = function() {return {World: World,MeshBox: MeshBox,Base: Base,MeshPyramid: MeshPyramid,Zone: Zone,Define: Define,Group: Group,Physics: Physics,Box: Box,Pyramid: Pyramid};}();function mapToBZW(map) {return map.objects.map((object)=>object.toString()).join("\n\n");}function cleanLine(line4) {if (line4.includes("#")) {line4 = line4.substring(0, line4.indexOf("#"));}line4 = line4.trim().replace(/ +(?= )/g, "");return line4;}function parse(source) {const map = {worldSize: 400,objects: []};let current = "";for (let line4 of source.split("\n")){line4 = cleanLine(line4);if (line4[0] === "#") {continue;}if (current === "define") {if (line4 === "enddef") {current = "";continue;}map.objects[map.objects.length - 1].parseLine(line4);continue;}if (line4 === "end") {current = "";} else if (line4 === "world") {current = line4;map.objects.push(new World(line4));} else if (line4 === "box") {current = line4;map.objects.push(new Box(line4));} else if (line4 === "meshbox") {current = line4;map.objects.push(new MeshBox(line4));} else if (line4 === "pyramid") {current = line4;map.objects.push(new Pyramid(line4));} else if (line4 === "meshpyr") {current = line4;map.objects.push(new MeshPyramid(line4));} else if (line4 === "base") {current = line4;map.objects.push(new Base(line4));} else if (line4 === "zone") {current = line4;map.objects.push(new Zone(line4));} else if (line4.startsWith("define")) {current = "define";map.objects.push(new Define(line4));} else if (line4.startsWith("group")) {current = "group";map.objects.push(new Group(line4));} else if (line4 === "physics") {current = "physics";map.objects.push(new Physics(line4));} else {switch(current){case "world":case "box":case "meshbox":case "pyramid":case "meshpyr":case "base":case "zone":case "define":case "group":case "physics":map.objects[map.objects.length - 1].parseLine(line4);if (current === "world" && line4.startsWith("size")) {map.worldSize = map.objects[map.objects.length - 1].size;}break;default: break;}}}for (const object of map.objects){if (object instanceof Group) {object.define = map.objects.find((otherObject)=>otherObject instanceof Define && otherObject.id === object.id);}}return map;}const canvas = document.querySelector("canvas");const bzwFile = document.querySelector("#bzw-file");const panels = {objects: document.querySelector("#objects > .panel__content"),properties: document.querySelector("#properties > .panel__content")};const statusBar = {objects: document.querySelector("#status--objects"),vertices: document.querySelector("#status--vertices")};const settings = {autoRotate: document.querySelector("#auto-rotate"),showAxis: document.querySelector("#show-axis")};function removeAllChildren(target) {while(target.lastChild){target.lastChild.remove();}}function load() {settings.autoRotate.checked = localStorage.getItem("autoRotate") === "true";settings.showAxis.checked = localStorage.getItem("showAxis") !== "false";colorThemeChanged();}function colorThemeChanged() {document.documentElement.setAttribute("data-theme", localStorage.getItem("colorTheme") ?? "default");}function setColorTheme(e) {if (!e) {return;}const target = e.target;if (target.classList.contains("menu")) {return;}localStorage.setItem("colorTheme", target.innerText.toLowerCase().replace(/ /g, "-"));colorThemeChanged();}setColorTheme();settings.autoRotate.addEventListener("change", ()=>{localStorage.setItem("autoRotate", settings.autoRotate.checked ? "true" : "false");});settings.showAxis.addEventListener("change", ()=>{localStorage.setItem("showAxis", settings.showAxis.checked ? "true" : "false");});const panels1 = JSON.parse(localStorage.getItem("panels") ?? "{}");for (const panel of document.querySelectorAll(".panel")){const header = panel.querySelector(".panel__header");if (!header) {continue;}header.draggable = true;header.addEventListener("dragstart", (e)=>{e.dataTransfer?.setData("text/plain", panel.id);}, false);panel.addEventListener("dragenter", (e)=>{e.preventDefault();panel.style.borderColor = "#FFF";}, false);panel.addEventListener("dragover", (e)=>{e.preventDefault();panel.style.borderColor = "#FFF";}, false);panel.addEventListener("dragleave", (e)=>{e.preventDefault();panel.style.borderColor = "";}, false);panel.addEventListener("drop", (e)=>{if (e.dataTransfer?.files.length ?? 0 > 0) {return;}e.stopPropagation();e.preventDefault();panel.style.borderColor = "";const id = e.dataTransfer?.getData("text/plain");if (!id || id === panel.id) {return;}const otherPanel = document.querySelector(`#${id}`);if (!otherPanel) {return;}const panelGridArea = window.getComputedStyle(panel).gridArea;const otherPanelGridArea = window.getComputedStyle(otherPanel).gridArea;panel.style.gridArea = otherPanelGridArea;otherPanel.style.gridArea = panelGridArea;if (panel.id === "preview" || otherPanel.id === "preview") {const canvas1 = document.querySelector("canvas");if (canvas1) {canvas1.width = 0;canvas1.height = 0;}}panels1[panel.id] = panel.style.gridArea;panels1[otherPanel.id] = otherPanel.style.gridArea;localStorage.setItem("panels", JSON.stringify(panels1));}, false);if (panels1[panel.id]) {panel.style.gridArea = panels1[panel.id];}}function getCoord(e, coord) {return e.touches ? e.touches[0][`page${coord}`] : e[`page${coord}`];}function saveFile(fileName, text) {const blob = new Blob([text], {type: "text/plain"});const link = document.createElement("a");link.download = fileName;link.href = window.URL.createObjectURL(blob);link.style.display = "none";document.body.appendChild(link);link.click();link.remove();}function capitalize(value) {return `${value.charAt(0).toUpperCase()}${value.slice(1)}`;}const VERTEX_SHADER = `#version 300 es\nlayout(location = 0) in vec3 position;\nlayout(location = 1) in vec4 color;\nlayout(location = 2) in vec3 normal;\n\nout vec4 vColor;\n\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\n\nconst vec3 SUN_POSITION_0 = normalize(vec3(0.3, 0.5, 0.8));\nconst vec3 SUN_POSITION_1 = normalize(vec3(-0.3, 0.5, -0.8));\nconst vec3 SUN_POSITION_2 = normalize(vec3(0.0, -1.0, 0.0));\nconst float AMBIENT = 0.3;\n\nfloat calculateLighting(vec3 sun){\n  return max(dot(normalize(normal), sun), 0.0);\n}\n\nvoid main(){\n  vColor = vec4(vec3(max(calculateLighting(SUN_POSITION_0) + calculateLighting(SUN_POSITION_1) + (calculateLighting(SUN_POSITION_2) * 0.7), AMBIENT)), 1.0) * color;\n\n  gl_Position = proj * view * model * vec4(position, 1.0);\n}`;const FRAGMENT_SHADER = `#version 300 es\nprecision highp float;\n\nin vec4 vColor;\n\nout vec4 finalColor;\n\nvoid main(){\n  if(vColor.a < .05){\n    discard;\n  }\n\n  finalColor = vColor;\n}`;const AXIS_VERTEX_SHADER = `#version 300 es\nlayout(location = 0) in vec3 position;\nlayout(location = 1) in vec4 color;\n\nout vec4 vColor;\n\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\n\nvoid main(){\n  vColor = color;\n  gl_Position = proj * view * model * vec4(position, 1.0);\n}`;function createShader(gl, vertCode, fragCode) {const vertShader = gl.createShader(gl.VERTEX_SHADER);if (!vertShader) {return null;}gl.shaderSource(vertShader, vertCode);gl.compileShader(vertShader);if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {console.error("Error compiling vertex shader: ", gl.getShaderInfoLog(vertShader));gl.deleteShader(vertShader);return null;}const fragShader = gl.createShader(gl.FRAGMENT_SHADER);if (!fragShader) {return null;}gl.shaderSource(fragShader, fragCode);gl.compileShader(fragShader);if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {console.error("Error compiling fragment shader: ", gl.getShaderInfoLog(fragShader));gl.deleteShader(fragShader);return null;}const shader = gl.createProgram();if (!shader) {return null;}gl.attachShader(shader, vertShader);gl.attachShader(shader, fragShader);gl.linkProgram(shader);return shader;}const MAX_ZOOM = -5;const MOUSE_SPEED = 75;class Renderer {worldSize = 400;axisPosition = [0,0,0];vbo = null;cbo = null;nbo = null;ebo = null;elementCount = 0;constructor(canvas1){if (!canvas1) {return;}this.gl = canvas1.getContext("webgl2", {antialias: true,alpha: true,depth: true});if (!this.gl) {alert("WebGL 2.0 not available");return;}const viewMatrix = [1,0,0,0,0,1,0,0,0,0,1,0,0,0,-this.worldSize,1];let drag = false;let oldX = 0, oldY = 0;let dX = 0, dY = 0;let THETA = 0, PHI = 40, oldTime = 0;new ResizeObserver(()=>{canvas1.width = canvas1.offsetWidth;canvas1.height = canvas1.offsetHeight;}).observe(canvas1);const mouseDown = (e)=>{e.preventDefault();drag = true;oldX = getCoord(e, "X");oldY = getCoord(e, "Y");};const mouseUp = ()=>{drag = false;};const mouseMove = (e)=>{e.preventDefault();if (!drag) {return;}const x = getCoord(e, "X");const y = getCoord(e, "Y");dX = (x - oldX) * MOUSE_SPEED * Math.PI / canvas1.width;dY = (y - oldY) * MOUSE_SPEED * Math.PI / canvas1.height;THETA += dX;PHI += dY;oldX = x;oldY = y;if (PHI > 90) {PHI = 90;} else if (PHI < -90) {PHI = -90;}};canvas1.addEventListener("mousedown", mouseDown, false);canvas1.addEventListener("mouseup", mouseUp, false);canvas1.addEventListener("mouseout", mouseUp, false);canvas1.addEventListener("mousemove", mouseMove, false);canvas1.addEventListener("touchstart", mouseDown, {passive: false});canvas1.addEventListener("touchend", mouseUp, false);canvas1.addEventListener("touchmove", mouseMove, {passive: false});canvas1.addEventListener("wheel", (e)=>{const delta = e.deltaY;viewMatrix[14] += delta / Math.abs(delta) * (viewMatrix[14] / 10);viewMatrix[14] = viewMatrix[14] > MAX_ZOOM ? MAX_ZOOM : viewMatrix[14] < -this.worldSize * 3 ? -this.worldSize * 3 : viewMatrix[14];}, {passive: true});const shader = createShader(this.gl, VERTEX_SHADER, FRAGMENT_SHADER);const axisShader = createShader(this.gl, AXIS_VERTEX_SHADER, FRAGMENT_SHADER);if (!shader || !axisShader) {alert("Error creating shader");return;}this.gl.useProgram(shader);const vMatrix = this.gl.getUniformLocation(shader, "view");const mMatrix = this.gl.getUniformLocation(shader, "model");this.gl.useProgram(axisShader);const avMatrix = this.gl.getUniformLocation(axisShader, "view");const amMatrix = this.gl.getUniformLocation(axisShader, "model");const axisVertices = [0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,-1,];const axisColors = [1,0,0,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,0,0,1,1];const axisVao = this.gl.createVertexArray();this.gl.bindVertexArray(axisVao);const axisVbo = this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER, axisVbo);this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(axisVertices), this.gl.STATIC_DRAW);const axisCbo = this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER, axisCbo);this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(axisColors), this.gl.STATIC_DRAW);this.gl.bindBuffer(this.gl.ARRAY_BUFFER, axisVbo);this.gl.enableVertexAttribArray(0);this.gl.vertexAttribPointer(0, 3, this.gl.FLOAT, false, 0, 0);this.gl.bindBuffer(this.gl.ARRAY_BUFFER, axisCbo);this.gl.enableVertexAttribArray(1);this.gl.vertexAttribPointer(1, 4, this.gl.FLOAT, false, 0, 0);this.gl.bindVertexArray(null);this.gl.deleteBuffer(axisVbo);this.gl.deleteBuffer(axisCbo);this.gl.enable(this.gl.DEPTH_TEST);this.gl.enable(this.gl.BLEND);this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);this.gl.enable(this.gl.CULL_FACE);this.gl.cullFace(this.gl.BACK);this.gl.clearColor(0, 0, 0, 0);const render = (time)=>{if (!this.gl) {return;}if (oldTime === 0) {oldTime = time;}const dt = time - oldTime;oldTime = time;if (!drag && settings.autoRotate.checked) {THETA += 0.015 * dt;}const modelMatrix = multiplyArrayOfMatrices([rotateXMatrix(-PHI),rotateYMatrix(-THETA),[1,0,0,0,0,1,0,0,0,0,1,0,-this.axisPosition[0],-this.axisPosition[2],this.axisPosition[1],1]]);this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);this.gl.viewport(0, 0, canvas1.width, canvas1.height);this.gl.useProgram(shader);this.gl.uniformMatrix4fv(this.gl.getUniformLocation(shader, "proj"), false, getProjection(60, canvas1.width / canvas1.height, 1, this.worldSize * 5));this.gl.uniformMatrix4fv(vMatrix, false, viewMatrix);this.gl.uniformMatrix4fv(mMatrix, false, modelMatrix);this.gl.drawElements(this.gl.TRIANGLES, this.elementCount, this.gl.UNSIGNED_SHORT, 0);if (settings.showAxis.checked) {this.gl.useProgram(axisShader);this.gl.uniformMatrix4fv(this.gl.getUniformLocation(axisShader, "proj"), false, getProjection(60, canvas1.width / canvas1.height, 1, this.worldSize * 5));this.gl.uniformMatrix4fv(avMatrix, false, viewMatrix);this.gl.uniformMatrix4fv(amMatrix, false, multiplyArrayOfMatrices([modelMatrix,[30,0,0,0,0,30,0,0,0,0,30,0,this.axisPosition[0],this.axisPosition[2],-this.axisPosition[1],1]]));this.gl.disable(this.gl.DEPTH_TEST);this.gl.bindVertexArray(axisVao);this.gl.drawArrays(this.gl.LINES, 0, 6);this.gl.bindVertexArray(null);this.gl.enable(this.gl.DEPTH_TEST);}requestAnimationFrame(render);};requestAnimationFrame(render);}updateMesh(mesh) {if (!this.gl) {return;}this.elementCount = mesh.indices.length;this.gl.deleteBuffer(this.vbo);this.gl.deleteBuffer(this.cbo);this.gl.deleteBuffer(this.nbo);this.gl.deleteBuffer(this.ebo);this.vbo = this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbo);this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(mesh.vertices), this.gl.STATIC_DRAW);this.cbo = this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.cbo);this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(mesh.colors), this.gl.STATIC_DRAW);const normals = calculateNormals(mesh.vertices, mesh.indices);this.nbo = this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.nbo);this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), this.gl.STATIC_DRAW);this.ebo = this.gl.createBuffer();this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.ebo);this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(mesh.indices), this.gl.STATIC_DRAW);this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbo);this.gl.enableVertexAttribArray(0);this.gl.vertexAttribPointer(0, 3, this.gl.FLOAT, false, 12, 0);this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.cbo);this.gl.enableVertexAttribArray(1);this.gl.vertexAttribPointer(1, 4, this.gl.FLOAT, false, 16, 0);this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.nbo);this.gl.enableVertexAttribArray(2);this.gl.vertexAttribPointer(2, 3, this.gl.FLOAT, false, 12, 0);this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);}}function calculateNormals(vertices, indices) {const x = 0;const y = 1;const z = 2;const ns = [];for(let i = 0; i < indices.length; i += 3){const v1 = [];const v2 = [];const normal = [];v1[x] = vertices[3 * indices[i + 1] + x] - vertices[3 * indices[i] + x];v1[y] = vertices[3 * indices[i + 1] + y] - vertices[3 * indices[i] + y];v1[z] = vertices[3 * indices[i + 1] + z] - vertices[3 * indices[i] + z];v2[x] = vertices[3 * indices[i + 2] + x] - vertices[3 * indices[i + 1] + x];v2[y] = vertices[3 * indices[i + 2] + y] - vertices[3 * indices[i + 1] + y];v2[z] = vertices[3 * indices[i + 2] + z] - vertices[3 * indices[i + 1] + z];normal[x] = v1[y] * v2[z] - v1[z] * v2[y];normal[y] = v1[z] * v2[x] - v1[x] * v2[z];normal[z] = v1[x] * v2[y] - v1[y] * v2[x];for(let j = 0; j < 3; j++){ns[3 * indices[i + j] + x] = normal[x];ns[3 * indices[i + j] + y] = normal[y];ns[3 * indices[i + j] + z] = normal[z];}}return ns;}const EDITOR_CHANGE_TIMEOUT = 15;const renderer = new Renderer(canvas);const randomMapID = Math.random().toString(36).slice(2);let storageName = window.decodeURI(window.location.hash.slice(1) || randomMapID);if (storageName === randomMapID) {history.replaceState(null, "", `#${window.encodeURI(storageName)}`);}let source = localStorage.getItem(`map-${storageName}`) ?? `# sample world\n\nworld\n  name ${randomMapID}\n  size 200\nend\n\nbox\n  position 0 0 0\n  size 30 30 15\n  rotation 45\nend\n\npyramid\n  position 50 50 0\n  size 5 5 50\nend\n\npyramid\n  position -50 50 0\n  size 5 5 50\nend\n\npyramid\n  position 50 -50 0\n  size 5 5 50\nend\n\npyramid\n  position -50 -50 0\n  size 5 5 50\nend\n\nbase\n  position -170 0 0\n  size 30 30 .5\n  color 1\nend\n\nbase\n  position 170 0 0\n  size 30 30 .5\n  color 2\nend\n`;let map = {worldSize: 400,objects: []};function handleFile(files) {const file = files ? files[0] : undefined;if (!file) {alert("No file selected!");return;}const reader = new FileReader();reader.addEventListener("load", ()=>{const text = reader.result;source = text;sourceChanged();});reader.addEventListener("error", ()=>{alert("Error: failed to read file");});reader.readAsText(file);}function saveMap() {saveFile(`${storageName}.bzw`, source);}function deleteMap() {localStorage.removeItem(`map-${storageName}`);window.location.href = "/";}function addObject(type) {if (!type) {return;}if (type === "box") {map.objects.push(new mod.Box());} else if (type === "meshbox") {map.objects.push(new mod.MeshBox());} else if (type === "pyramid") {map.objects.push(new mod.Pyramid());} else if (type === "meshpyr") {map.objects.push(new mod.MeshPyramid());} else if (type === "base") {map.objects.push(new mod.Base());} else if (type === "zone") {map.objects.push(new mod.Zone());} else if (type === "physics") {map.objects.push(new mod.Physics());} else {return alert("Unsupported object type");}source = mapToBZW(map);_sourceChanged(false);setSelectedMapObject(map.objects.length - 1);}addObject();function _sourceChanged(updateSelected = true) {parseSource(updateSelected);updateMesh();localStorage.setItem(`map-${storageName}`, source);}let timeoutId = 0;function sourceChanged(updateSelected = true) {if (timeoutId) {clearTimeout(timeoutId);}timeoutId = setTimeout(()=>_sourceChanged(updateSelected), EDITOR_CHANGE_TIMEOUT);}bzwFile.addEventListener("change", ()=>{handleFile(bzwFile.files);});let selectedMapObjectIndex = -1;function setSelectedMapObject(newIndex) {if (newIndex === selectedMapObjectIndex) {return;}selectedMapObjectIndex = newIndex;if (selectedMapObjectIndex < 0) {return;}const selectedMapObject = map.objects[selectedMapObjectIndex];if (selectedMapObject.position) {renderer.axisPosition = selectedMapObject.position;} else {renderer.axisPosition = [0,0,0];}removeAllChildren(panels.properties);const typeElement = document.createElement("div");typeElement.innerText = `Type: ${capitalize(selectedMapObject.HEADER)}`;panels.properties.appendChild(typeElement);const properties = Object.keys(selectedMapObject);const values = Object.values(selectedMapObject);for(const i in properties){const property = properties[i];const value = values[i];if (["vertexCount","HEADER"].includes(property)) {continue;}if (selectedMapObject.HEADER === "zone" && property === "color" || selectedMapObject.HEADER === "group" && property === "position") {continue;}const nameElement = document.createElement("span");nameElement.innerText = `${capitalize(property.split(/([A-Z])/g).map((value1, i1, array)=>{if (value1.length > 1 && i1 > 0) {return `${array[i1 - 1]}${value1}`;}return value1;}).filter((value1)=>value1.length !== 1).join(" "))}`;panels.properties.appendChild(nameElement);const valueElement = document.createElement("div");const createInputElement = (type, value1, changedHandler)=>{const inputElement = document.createElement("input");inputElement.type = type;inputElement.spellcheck = false;if (type === "checkbox") {inputElement.checked = value1;} else {inputElement.value = value1;}inputElement.addEventListener("input", ()=>{if (selectedMapObjectIndex === -1) {return;}changedHandler(inputElement);source = mapToBZW(map);sourceChanged();});valueElement.appendChild(inputElement);};switch(typeof value){case "string":{createInputElement("text", value, (inputElement)=>{map.objects[selectedMapObjectIndex][property] = inputElement.value;});}break;case "number":{createInputElement("number", `${value}`, (inputElement)=>{map.objects[selectedMapObjectIndex][property] = parseNum(inputElement.value);});}break;case "boolean":{createInputElement("checkbox", value, (inputElement)=>{map.objects[selectedMapObjectIndex][property] = inputElement.checked;});}break;case "undefined":{const createElement = document.createElement("button");createElement.classList.add("btn");createElement.innerText = "Edit";createElement.addEventListener("click", ()=>{if (selectedMapObjectIndex === -1) {return;}if (property === "color") {map.objects[selectedMapObjectIndex][property] = [0,0,0,1];source = mapToBZW(map);sourceChanged();const index = parseInt(`${selectedMapObjectIndex}`);selectedMapObjectIndex = -1;setSelectedMapObject(index);} else {alert("something somewhere is messed up big time");}});valueElement.appendChild(createElement);}break;case "object":{if (Array.isArray(value) && typeof value[0] === "number") {for(const valueIndex in value){createInputElement("number", `${value[valueIndex]}`, (inputElement)=>{map.objects[selectedMapObjectIndex][property][valueIndex] = parseNum(inputElement.value);});}if (property === "color") {const deleteElement = document.createElement("button");deleteElement.classList.add("btn");deleteElement.innerText = "Reset";deleteElement.addEventListener("click", ()=>{if (selectedMapObjectIndex === -1) {return;}if (property === "color") {map.objects[selectedMapObjectIndex][property] = undefined;source = mapToBZW(map);sourceChanged();const index = parseInt(`${selectedMapObjectIndex}`);selectedMapObjectIndex = -1;setSelectedMapObject(index);} else {alert("something somewhere is messed up big time");}});valueElement.appendChild(deleteElement);}} else {valueElement.innerText = "unsupported property";}}break;default:valueElement.innerText = "unsupported property";break;}panels.properties.appendChild(valueElement);}for (const selected of panels.objects.querySelectorAll(".selected")){selected.classList.remove("selected");}Array.from(panels.objects.children)[selectedMapObjectIndex].classList.add("selected");}panels.objects.addEventListener("click", (e)=>{const target = e.target;if (!target || !target.parentElement || !target.parentElement.classList.contains("panel__content")) {return;}const index = Array.from(target.parentElement.children).indexOf(target);setSelectedMapObject(index);});window.addEventListener("dragenter", (e)=>{e.stopPropagation();e.preventDefault();});window.addEventListener("dragover", (e)=>{e.stopPropagation();e.preventDefault();});window.addEventListener("drop", (e)=>{e.stopPropagation();e.preventDefault();handleFile(e.dataTransfer?.files);});window.onkeydown = (e)=>{if (e.keyCode === 68 && e.ctrlKey && e.shiftKey) {e.preventDefault();deleteMap();} else if (e.keyCode === 68 && e.ctrlKey) {e.preventDefault();saveMap();} else if (e.keyCode === 79 && e.ctrlKey) {e.preventDefault();bzwFile.click();} else if (e.keyCode === 83 && e.ctrlKey) {e.preventDefault();alert("WebBZW automatically saves your work! You can use Ctrl+D to download the file or Ctrl+C to copy the contents to your clipboard.");} else if (e.keyCode === 65 && e.altKey) {e.preventDefault();addObject(prompt("Type of object:") ?? undefined);} else if (e.keyCode === 82 && e.altKey) {e.preventDefault();removeObject();}};document.addEventListener("copy", (e)=>{e.preventDefault();(e.clipboardData || window.clipboardData).setData("text/plain", source);}, false);document.addEventListener("paste", (e)=>{e.preventDefault();source = (e.clipboardData || window.clipboardData).getData("text");sourceChanged();}, false);document.addEventListener("DOMContentLoaded", ()=>{load();_sourceChanged();});function parseSource(updateSelected = true) {const oldSelected = map.objects[selectedMapObjectIndex]?.toString() ?? "";const oldLength = map.objects.length;map = parse(source);if (!updateSelected || map.objects.length !== oldLength) {removeAllChildren(panels.objects);for (const object of map.objects){const div = document.createElement("div");div.innerText = `${object.name || object.HEADER} [${object.HEADER}]`;panels.objects.appendChild(div);}}if (updateSelected && (map.objects[selectedMapObjectIndex]?.toString() ?? "") !== oldSelected) {const index = parseInt(`${selectedMapObjectIndex}`);selectedMapObjectIndex = -1;setSelectedMapObject(index);}const newStorageName = map.objects.find((object)=>object instanceof mod.World)?.name || storageName;if (newStorageName !== storageName) {if (localStorage.getItem(`map-${newStorageName}`) && !confirm("You are about to overwrite an existing map - are you sure?")) {const world = map.objects.find((object)=>object instanceof mod.World);if (world) {world.name = storageName;source = mapToBZW(map);sourceChanged();const index = parseInt(`${selectedMapObjectIndex}`);selectedMapObjectIndex = -1;setSelectedMapObject(index);}return;}localStorage.removeItem(`map-${storageName}`);history.replaceState(null, "", `#${window.encodeURI(newStorageName)}`);storageName = newStorageName;}}function updateMesh() {const mesh = {vertices: [],indices: [],colors: [],indicesCount: 0};if (!map.objects.find((object)=>object instanceof mod.World)) {map.objects.push(new mod.World());map.worldSize = map.objects[map.objects.length - 1].size;}for (const object of [...map.objects].sort((a, b)=>(a.color?.[3] ?? -1) > (b.color?.[3] ?? 1) ? 1 : -1)){object.buildMesh(mesh);}renderer.worldSize = map.worldSize;renderer.updateMesh(mesh);statusBar.objects.innerText = `${map.objects.length} Objects`;statusBar.vertices.innerText = `${mesh.indices.length} Vertices`;}function removeObject() {if (selectedMapObjectIndex < 1) {return;}map.objects.splice(selectedMapObjectIndex, 1);source = mapToBZW(map);_sourceChanged(false);setSelectedMapObject(selectedMapObjectIndex - 1);}removeObject();</script>
</body>
</html>
